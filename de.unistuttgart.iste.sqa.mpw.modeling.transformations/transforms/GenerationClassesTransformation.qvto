import facade.GameFacadeElementsLibrary;
import facade.StageBuilderLibrary;

modeltype Ecore uses ecore('http://www.eclipse.org/emf/2002/Ecore');

modeltype CommandModel uses 'http://www.mpw.uni-stuttgart.de/behavior/command';
modeltype QueryModel uses 'http://www.mpw.uni-stuttgart.de/behavior/query';
modeltype GenerationAnnotations uses 'http://www.mpw.uni-stuttgart.de/generation/annotations';

/**
  *  Transformation which transforms Ecore models by inserting facade classes for Actors and Stages.
  *
  *  It embeds GenerationAnnotations into the created EClasses which includes simple behavior and statements. The generation
  *  then simply can make use of this annotations to generate code.
  *
  *  The transformation is splitted into libraries 'facade.GameFacadeElementsLibrary' and 'facade.StageBuilderLibrary'.
  *
  *  Note: later this transformation shall also be used to copy also all other EClassifiers and insert GenerationAnnotations
  *        to move much more logic from the generator to the transformation stage. This pattern may later also be used for the
  *        QueryTransformation.qvto and CommandTransformation.qvto.
  */
transformation GenerationClassesTransformation(in inEcore: Ecore, out outEcore: Ecore);

main() {
    inEcore.rootObjects()[EPackage]->map transformPackage();
}

mapping EPackage::transformPackage() : EPackage {
    name := self.name;
    nsURI := self.nsURI + "/generation";
    nsPrefix := self.nsPrefix;
    eAnnotations += "facade".toMarkerAnnotation();
    
    addEntityModelToGlobalSearchList(result);
    
    var facadeClasses := self.eClassifiers[EClass][hasAnnotationValue("role", "game")]->map toGameFacadeClass();
    eClassifiers += facadeClasses;
    
    // generate elements of facade after classes are created, since they may rely on other facade types
    facadeClasses->map createElements();
    
    eClassifiers += self.eClassifiers[EClass][hasAnnotationValue("role", "editor")]->map createBuilderClass();
    
    self.eClassifiers[EClass][isInstanceOf("MiniProgrammingWorld")]->map useFacades();
}

mapping EClassifier::toClassifier() : EClassifier
    disjuncts EClass::toClassifier,
              EEnum::toClassifier {}

mapping EClass::toClassifier() : EClass {
    name := self.name;
}

mapping EEnum::toClassifier() : EEnum {
    name := self.name;
}

mapping EClass::toImplClass() : EClass {
    name := self.name + "Impl";
}

mapping EClass::toGameFacadeClass() : EClass {
    var baseName := self.getAnnotationValue("baseName");
    name := baseName;
}

// MiniProgrammingWorld classes have to use facade classes
mapping inout EClass::useFacades() {
    eReferences->forEach(f) {
    	if (f.eType.isMarkedWithAnnotation("role")) {
    	    var baseName := f.eType.getAnnotationValue("baseName");
    		f.eType := findClassForName(baseName);
    		f.eAnnotations += object InlineSimpleFieldInitializationAnnotation {
    			field := f;
    			parameterInputVariablePropertyPaths += "this";
    		};
    	}
    };
}

