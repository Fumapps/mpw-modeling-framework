import helpers.EmfHelpers;

modeltype ecore uses ecore('http://www.eclipse.org/emf/2002/Ecore');
	
modeltype Input uses "http://www.mpw.uni-stuttgart.de/querydsl";
modeltype QueryModel uses "http://www.mpw.uni-stuttgart.de/behavior/query";

library StatementTransformation;

configuration property Queries: List(querydsl::Model);
configuration property EntityModels: List(EPackage);

// remember the "current" statement / expression's type of the input model (to use in when blocks)
property currentExpressionTypes: Dict(Input::Expression, ecore::EClassifier);
property currentExpressionTypeCollectionInfo: Dict(Input::Expression, ecore::EBoolean);

mapping Input::Statement::toStatement() : QueryModel::Statement
    disjuncts Input::Statement::toSelfStatement,
              Input::Statement::toQueryStatement,
              Input::Statement::toFeatureStatement,
              Input::Statement::toCollectionMethodStatement,
              Input::Statement::toEnumLiteralStatement { }

abstract mapping Input::Statement::toStatementBase() : QueryModel::Statement {
    init {
    	var statementIndex := self.parentExpression().statements->indexOf(self);
    	if (statementIndex > 0) {
    		var predecessorInput := self.parentExpression().statements->at(statementIndex-1);
    		result.previous := predecessorInput.resolveoneIn(Input::Statement::toStatement);
    	}
    }
    end {
        result.debugName := self.toDebugName();
        currentExpressionTypes->put(self.parentExpression(), result.eType);
        currentExpressionTypeCollectionInfo->put(self.parentExpression(), result.isCollection);
    }
}

mapping Input::Statement::toSelfStatement() : QueryModel::SelfStatement merges Input::Statement::toStatementBase
    when { self.target = "self"; } {
    eType := self.parentModel().context.className.resolveone(ecore::EClass);
    selfAlias := self.determineSelfAlias();
}

query Input::Statement::determineSelfAlias() : String {
    if (self.parentModel().context.kind = ContextKind::QUERY) {
        return "this";
    } else {
        return "thisInstance";
    };
}

mapping Input::Statement::toQueryStatement() : QueryModel::QueryStatement merges Input::Statement::toStatementBase
    when { self.isBasedOnQuery(); } {
    var inputQuery := Queries->any(q|isStatementMatchingQuery(self, q));
    _query := inputQuery.late resolveone(QueryModel::Query);
    eType := _query.eType;
}

mapping Input::Statement::toFeatureStatement() : QueryModel::FeatureStatement merges Input::Statement::toStatementBase
    when { self.getCurrentExpressionType().oclIsTypeOf(ecore::EClass) and self.target != null; } {
    var eClass := self.getCurrentExpressionType().oclAsType(ecore::EClass);
    
    feature := eClass.eAllStructuralFeatures->any(f|f.name = self.target);
    isCollection := feature.upperBound = -1;
    eType := feature.eType;
}

mapping Input::Statement::toCollectionMethodStatement() : QueryModel::CollectionMethodStatement merges Input::Statement::toStatementBase
    when { self.getCurrentExpressionTypeIsCollection() = true and self.collectionTarget != null; } {
    var eClass := self.getCurrentExpressionType().oclAsType(ecore::EClass);
    
    var isSimple := self.collectionTarget.oclIsTypeOf(Input::SimpleCollectionMethod);
    var simpleCollectionMethod := self.collectionTarget.oclAsType(Input::SimpleCollectionMethod);
    var parametrizedCollectionMethod := self.collectionTarget.oclAsType(Input::ParametrizedCollectionMethod);
    
    switch {
        case (isSimple and simpleCollectionMethod.method = "notEmpty") {
            eType := ecore::EBoolean.oclAsType(ecore::EClassifier);
            isCollection := false;
            methodType := QueryModel::CollectionMethodType::NOT_EMPTY;
        }
        case (isSimple and simpleCollectionMethod.method = "isEmpty") {
            eType := ecore::EBoolean.oclAsType(ecore::EClassifier);
            isCollection := false;
            methodType := QueryModel::CollectionMethodType::IS_EMPTY;
        }
        case (not isSimple and parametrizedCollectionMethod.typeSelect != null) {
            eType := findClassifierForName(parametrizedCollectionMethod.typeSelect);
            isCollection := true;
            methodType := QueryModel::CollectionMethodType::TYPE_SELECT;
            parameters += eType.oclAsType(ecore::EObject);
        }
        else {
            assert(false);
        }
    };
}

mapping Input::Statement::toEnumLiteralStatement() : QueryModel::EnumLiteralStatement merges Input::Statement::toStatementBase
    when { self.isEnumLiteral(); } {
    enumLiteral := EntityModels->collect(m|m.allSubobjectsOfType(ecore::EEnumLiteral))->flatten()->any(l|l.name = self.target);
    eType := enumLiteral.container().oclAsType(ecore::EEnum);
}

helper Input::Statement::parentExpression() : Input::Expression {
	return self.container().oclAsType(querydsl::Expression);
}

helper Input::Statement::parentModel() : Input::Model {
	return self.root().oclAsType(Input::Model);
}

query Input::Statement::isBasedOnQuery() : Boolean {
    return Queries->exists(q|isStatementMatchingQuery(self, q));
}

query isStatementMatchingQuery(s: Input::Statement, q: Input::Model) : Boolean {
    return q.context.kind = querydsl::ContextKind::QUERY 
           and q.context.name + "()" = s.target
           and currentExpressionTypes->get(s.parentExpression()).name = q.context.className;
}

query Input::Statement::isEnumLiteral() : Boolean {
    return EntityModels->collect(m|m.allSubobjectsOfType(ecore::EEnumLiteral))->flatten()->exists(l|l.name = self.target);
}

/* returns the current expression type which is defined by the previous statement */
query Input::Statement::getCurrentExpressionType() : ecore::EClassifier {
    return currentExpressionTypes->get(self.parentExpression());
}

query Input::Statement::getCurrentExpressionTypeIsCollection() : ecore::EBoolean {
    return currentExpressionTypeCollectionInfo->get(self.parentExpression());
}

query ecore::EString::findClass() : ecore::EClassifier {
    return EntityModels->collect(p|p.getEClassifier(self))->selectOne(c|c != null).oclAsType(ecore::EClass)
}

/* create a display string which is helpful when viewing as XMI */
query Input::Statement::toDebugName() : ecore::EString {
    if (self.target != null) {
        return self.target;
    };
    
    var simpleCollectionMethod := self.collectionTarget.oclAsType(Input::SimpleCollectionMethod);
    if (simpleCollectionMethod != null) {
        return simpleCollectionMethod.method;
    };
    var parametrizedCollectionMethod := self.collectionTarget.oclAsType(Input::ParametrizedCollectionMethod);
    if (parametrizedCollectionMethod != null) {
        return parametrizedCollectionMethod.typeSelect;
    };
    
    return "?";
}
