import helpers.AnnotationHelpers;
import helpers.EmfHelpers;

modeltype Ecore uses ecore('http://www.eclipse.org/emf/2002/Ecore');

modeltype CommandModel uses 'http://www.mpw.uni-stuttgart.de/behavior/command';
modeltype QueryModel uses 'http://www.mpw.uni-stuttgart.de/behavior/query';
modeltype GenerationAnnotations uses 'http://www.mpw.uni-stuttgart.de/generation/annotations';

library FacadeElementsLibrary;

mapping inout EClass::createElements()
    disjuncts EClass::createActorGameFacadeElements,
              EClass::createStageGameFacadeElements {}

abstract mapping inout EClass::createElementsBase() {
    var baseName := self.name;
    self.eStructuralFeatures += object EReference {
        name := "game";
        eType := findInstanceOfMetaClass("MiniProgrammingWorld");	
    };
    
    var internalGameRoleField := object EReference {
        name := "internal" + baseName;
        eType := findClassifierForName("Game" + baseName); 
    };
    self.eStructuralFeatures += internalGameRoleField;
    
    self.eAnnotations += object GetPropertyAnnotation {
    	field := internalGameRoleField;
    };
}

mapping inout EClass::createActorGameFacadeElements() inherits EClass::createElementsBase
    when { self.getConcreteClass().eAllSuperTypes->exists(t|t.name = "Actor") } {
    
    var concreteClass := self.getConcreteClass();
    
    var constructorOperation := object EOperation {
    	name := self.name;
    	eAnnotations += "constructor".toMarkerAnnotation();
    };
    eOperations += constructorOperation;
    var initCommand := concreteClass.eAllOperations->any(o|o.isMarkedWithAnnotation("command") and getCommandForOperation(o).isInit);
    
    var constructorWithParamsOperation := object EOperation {
    	name := self.name;
    	
    	eParameters += getCommandForOperation(initCommand).mainUnit.parameters->map toOperationParameter();

    	eAnnotations += "constructor".toMarkerAnnotation();
    };
    eOperations += constructorWithParamsOperation;
    
    self.map createCommands();
    self.map createQueries();
}

mapping inout EClass::createStageGameFacadeElements() inherits EClass::createElementsBase
    when { self.getConcreteClass().eAllSuperTypes->exists(t|t.name = "Stage") } {
    
    var constructorOperation := object EOperation {
    	name := self.name;
    	eParameters += object EParameter {
    	    name := "game";
    	    eType := findInstanceOfMetaClass("MiniProgrammingWorld");
    	};
    	eAnnotations += "constructor".toMarkerAnnotation();
    };
    eOperations += constructorOperation;
    
    constructorOperation.eAnnotations += constructorOperation.map toAssignParameterToFieldAnnotation("game", "game");
    
    self.map createCommands();
    self.map createQueries();
}

mapping EOperation::toAssignParameterToFieldAnnotation(parameterName: String, fieldName: String) : ParameterToFieldAssignmentAnnotation {
    parameter := self.eParameters->any(p|p.name = parameterName);
    targetFeature := self.eContainingClass.eAllStructuralFeatures->any(f|f.name = fieldName);
}

query EClass::getConcreteClass() : EClass {
	var baseName := self.name;
	return findClassifierForName("Concrete" + baseName).oclAsType(EClass);
}

query getCommandForOperation(operation: EOperation) : Transformation {
    return operation.eAnnotations
                   ->selectOne(a|a.source = "command")
                    .contents
                   ->first()
                    .oclAsType(Transformation);
}

query getQueryForOperation(operation: EOperation) : Query {
    return operation.eAnnotations
                   ->selectOne(a|a.source = "query")
                    .contents
                   ->first()
                    .oclAsType(Query);
}

mapping CommandModel::Parameter::toOperationParameter() : EParameter {
    name := self.name;
    eType := findClassifierForName(self.type);
    
    // facades do rely on other facade types, e.g. Hamster -> Territory instead of GameTerritory
    if (eType.isMarkedWithAnnotation("role")) {
        var baseName := eType.getAnnotationValue("baseName");
    	eType := findClassifierForName(baseName);
    }
}

mapping inout EClass::createCommands() {
    var gameRole := findClassForName("Game" + self.name);
    gameRole.eAllOperations[isMarkedWithAnnotation("command")]
           ->collect(o|getCommandForOperation(o))
           ->forEach(c) {
	    self.eOperations += object EOperation {
	        if (c.isInit) {
	            name := "init";
                eParameters := c.mainUnit.parameters->clone()->map toOperationParameter(); // already mapped by constructor: now clone it to avoid removement on constructor parameters
	        } else {
  	            name := c.name;
                eParameters := c.mainUnit.parameters->map toOperationParameter();
	        };
	        eAnnotations += object CommandCallAnnotation { command := c; };
	    };
    };
}

mapping inout EClass::createQueries() {
    var readOnlyRole := findClassForName("ReadOnly" + self.name);
    readOnlyRole.eAllOperations[isMarkedWithAnnotation("query")]
               ->collect(o|getQueryForOperation(o))
               ->forEach(q) {
	    self.eOperations += object EOperation {
	        name := q.name;
	        eType := q.eType;
            eAnnotations += object QueryCallAnnotation { 
                _query := q;
                internalRoleField := self.getEStructuralFeature("internal" + self.name).oclAsType(EReference);
            };
	    };
    };
}
