import helpers.AnnotationHelpers;
import helpers.EmfHelpers;
import helpers.BasicHelpers;
import facade.FacadeElementsLibrary;

modeltype Ecore uses ecore('http://www.eclipse.org/emf/2002/Ecore');

modeltype CommandModel uses 'http://www.mpw.uni-stuttgart.de/behavior/command';
modeltype QueryModel uses 'http://www.mpw.uni-stuttgart.de/behavior/query';
modeltype GenerationAnnotations uses 'http://www.mpw.uni-stuttgart.de/generation/annotations';

library StageBuilderLibrary;

mapping EClass::createBuilderClass() : EClass
    when { self.getConcreteClass().eAllSuperTypes->exists(t|t.name = "Stage") } {
    name := self.getBaseName() + "Builder";
    eAnnotations += toAnnotation("baseName", self.getBaseName());
    
    result.map createFields();
    result.map createConstructor();
    result.eOperations += self.eAllOperations[isMarkedWithAnnotation("command")]->collect(o|getCommandForOperation(o))->map toBuilderOperation(result);
    result.eOperations += result.eOperations[eParameters->exists(p|p.name = "location" and p.eType.name = "Location")]->map cloneSimplifiedBuilderOperation();
    result.map createBuildOperation();
}

abstract mapping inout EClass::createFields() {
    var baseName := self.getBaseName();
    
    var internalEditorRoleField := object EReference {
        name := baseName.firstToLower();
        eType := findClassifierForName("Editor" + self.getBaseName());
    };
    eStructuralFeatures += internalEditorRoleField;
    
    self.eStructuralFeatures += object EReference {
        name := "game";
        eType := findInstanceOfMetaClass("MiniProgrammingWorld");	
    };
    
    var resultCommandField := object EReference {
        name := "resultCommand";
        eType := findClassifierForName("CompositeCommand");
        containment := true;
    };
    eStructuralFeatures += resultCommandField;
}

abstract mapping inout EClass::createConstructor() {
    var baseName := self.getBaseName();

    var constructorOperation := object EOperation {
    	name := self.name;
    	
        var gameParameter := object EParameter {
    	    name := "game";
    	    eType := findInstanceOfMetaClass("MiniProgrammingWorld");
    	};
    	eParameters += gameParameter;
    	
    	eAnnotations += "constructor".toMarkerAnnotation();
    	
    	eAnnotations += object ParameterToFieldAssignmentAnnotation {
    		targetFeature := self.getEStructuralFeature("game");
    		parameter := gameParameter;
    	};
    	
    	eAnnotations += object PropertyPathFieldAssignmentAnnotation {
    		targetFeature := self.getEStructuralFeature(baseName.firstToLower());
    		propertyPath := "game.territory.internalEditor" + baseName;
    	};
    	
    	eAnnotations += object ConstructorSimpleFieldInitializationAnnotation {
    		field := self.getEStructuralFeature("resultCommand");
    		constructorTypeName := "SimpleCompositeCommand";
    	};
    	self.eAnnotations += object ImportTypeAnnotation {
    		relativeQualifiedTypeName := "command.impl.*"
    	};
    	
    	eAnnotations += toAnnotation("documentation", "Creates a new " + self.name + " object which then can be used to defined the given " + baseName + ".");
    };
    eOperations += constructorOperation;
    
}

mapping Transformation::toBuilderOperation(parentBuilderClass: EClass) : EOperation {
    name := self.name;
    eType := parentBuilderClass;
    
    eParameters := self.mainUnit.parameters->map toOperationParameter();
    eAnnotations += toAnnotation("documentation", self.documentation);
    
    eAnnotations += object CommandParameterCreationAnnotation { 
        command := self;
        parameterMappings := self.mainUnit.parameters->map toCommandCallParameterMapping();
    };
    
    eAnnotations += object CommandCreationAnnotation { 
        command := self;
    };
    
    eAnnotations += object AddVariableToCollectionAnnotation { 
        collectionPropertyPath := "resultCommand.subCommands";
        parameterPropertyPath := "command";
    };
    
    eAnnotations += object PropertyPathReturnAnnotation {
	    propertyPath := "this";
	};
}

mapping EOperation::cloneSimplifiedBuilderOperation() : EOperation {
    name := self.name;
    eType := self.eType;
    
    self.eParameters->forEach(p) {
    	if (p.name = "location") {
    		eParameters += object EParameter {
    			name := "locationX";
    			eType := EInt.oclAsType(EClassifier);
    		};
    		eParameters += object EParameter {
    			name := "locationY";
    			eType := EInt.oclAsType(EClassifier);
    		};
    	} else {
    		eParameters += p.deepclone();
    	}
    };
    
    eAnnotations += object VariableObjectConstructionAnnotation {
    	variableName := "location";
    	parameterInputVariablePropertyPaths += "locationX";
    	parameterInputVariablePropertyPaths += "locationY";
    	constructorTypeName := "Location";
    };
    
    eAnnotations += self.eAnnotations.deepclone();
}

abstract mapping inout EClass::createBuildOperation() {
    var baseName := self.getBaseName();

    var buildOperation := object EOperation {
    	name := "build";
    	eType := findClassForName("Command");
    	eAnnotations := object PropertyPathReturnAnnotation {
    	    propertyPath := "resultCommand";
    	};
    };
    eOperations += buildOperation;
    
}
