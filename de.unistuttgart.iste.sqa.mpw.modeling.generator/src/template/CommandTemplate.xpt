«IMPORT commandgt»

«EXTENSION template::util::GeneratorExtensions»

«DEFINE main FOR Transformation»
    «FILE this.getCommandJavaPackagePath() + "/" + name.toFirstUpper() + "Command.java"»package «this.getCommandJavaPackageName()»;
    	
        import static de.unistuttgart.hamster.framework.FrameworkAssert.*;
    	«EXPAND template::types::ImportUsedTypesTemplate::CommandEntityImportDefinition FOR targetClass»
    	import «getModulePackage()».mpw.*;
    	import «getModulePackage()».command.*;
    	import static «getModulePackage()».mpw.Direction.*;
    	
		public class «name.toFirstUpper()»Command {
			private final «targetClass.getConcreteName()» thisInstance;
			«IF mainUnit != null»
			«FOREACH mainUnit.parameters AS p»
			private final «p.type.toJavaType()» «p.name»;
			«ENDFOREACH»
			«ENDIF»
		
			public «name.toFirstUpper()»Command(«targetClass.getConcreteName()» self«FOREACH mainUnit.parameters AS p», «p.type.toJavaType()» «p.name»«ENDFOREACH») {
				this.thisInstance = self;
				
				«IF mainUnit != null»
				«FOREACH mainUnit.parameters AS p»
				this.«p.name» = «p.name»;
				«ENDFOREACH»
				«ENDIF»
			}
		
			«EXPAND UnitExpand FOR mainUnit»
            «EXPAND UnitExpand FOREACH units.excluding(mainUnit)»
        }
    «ENDFILE»
«ENDDEFINE»

«DEFINE UnitExpand FOR Unit»
	«getVisibility()» void «name»(«IF name != "execute"»«FOREACH parameters AS p SEPARATOR ", "»«p.type.toJavaType()» «p.name»«ENDFOREACH»«ENDIF») {
	«IF this == ((Transformation)eContainer).mainUnit-»
	«EXPAND Preconditions FOR this»
	«ENDIF-»
	«EXPAND UnitExpandBody FOR this»
	}
«ENDDEFINE»

«DEFINE UnitExpandBody FOR Unit»«ENDDEFINE»

«DEFINE UnitExpandBody FOR ConditionalUnit»
    if«FOREACH conditions AS c SEPARATOR " else if "-»
    («c.condition.toPropertyGetters()») {
	«EXPAND UnitInvokeExpand FOR c.unit»
	}
    «ENDFOREACH»
«ENDDEFINE»

«DEFINE UnitExpandBody FOR SequentialUnit»
	«EXPAND UnitInvokeExpand FOR this»
«ENDDEFINE»

«DEFINE UnitExpandBody FOR IteratedUnit»
	«EXPAND UnitInvokeExpand FOR this»
«ENDDEFINE»

«DEFINE UnitInvokeExpand FOR Unit»«ENDDEFINE»

«DEFINE UnitInvokeExpand FOR SequentialUnit»
	«FOREACH targetInvocations AS i»
	«i.targetMethodName»(«FOREACH i.mappedParameters AS p SEPARATOR ", "»«p.name»«ENDFOREACH»);
	«ENDFOREACH»
«ENDDEFINE»

«DEFINE UnitInvokeExpand FOR IteratedUnit»
	for (int i = 0; i < («repeat»); i++) {
		«targetInvocation.targetMethodName»(«FOREACH targetInvocation.mappedParameters AS p SEPARATOR ", "»«p.name»«ENDFOREACH»);
	}
«ENDDEFINE»

«DEFINE UnitInvokeExpand FOR Rule»
    «name»();
«ENDDEFINE»

«DEFINE UnitExpand FOR Rule»
    «getVisibility()» void «name»() {
    «IF this == ((Transformation)eContainer).mainUnit-»
    «EXPAND Preconditions FOR this»
    «ENDIF-»
    «EXPAND VariableDefinition FOREACH variables»
    «EXPAND InstanceDefinition FOREACH instanceConditions»
    «EXPAND ReferenceDefinition FOREACH referenceConditions»
    «EXPAND AttributeDefinition FOREACH attributeConditions»
    «EXPAND RemoveModificationDefinition FOREACH modifications.select(m|m.action == Action::DELETE)»
    «EXPAND CreateModificationDefinition FOREACH modifications.select(m|m.action == Action::CREATE)»
    «EXPAND AttributeModificationDefinition FOREACH modifications.select(m|m.action == Action::MODIFY)»
    }
    «EXPAND FindObjectDefinition FOREACH referenceConditions.typeSelect(ManyReferenceCondition).select(r|!r.isCreate)»
«ENDDEFINE»

«DEFINE ThisInstanceDefinition FOR InstanceCondition»
    // this: «this.variableName»:«this.typeName»
«ENDDEFINE»

«DEFINE InstanceDefinition FOR InstanceCondition»
	«IF isCreate»
		// new instance: «this.variableName»:«this.typeName»
    	«this.typeName» «this.variableName» = HamsterFactoryImpl.eINSTANCE.create«this.typeName»();
	«ENDIF»
«ENDDEFINE»

«DEFINE VariableDefinition FOR VariableDeclaration»
    // new variable «this.name»: «this.type»
    «this.type.toJavaType()» «this.name»;
«ENDDEFINE»

«DEFINE ReferenceDefinition FOR ReferenceCondition»
	«IF this.metaType == SingleReferenceCondition»
      «EXPAND SingleReferenceDefinition FOR (SingleReferenceCondition)this»
    «ELSE»
      «EXPAND ManyReferenceDefinition FOR (ManyReferenceCondition)this»
	«ENDIF»
«ENDDEFINE»

«DEFINE SingleReferenceDefinition FOR SingleReferenceCondition»
	«IF !this.isCreate && !this.isForbid»
		// new variable from reference: «this.source.variableName»:«this.source.typeName» -> «this.referenceName» -> «this.target.variableName»:«this.target.typeName»
		«this.target.typeName» «this.target.variableName» = «this.source.variableName».«getter(this.referenceName)»();
		assertInstanceNotNull("«this.source.variableName».«this.referenceName»", «this.target.variableName»);
	«ENDIF»
«ENDDEFINE»

«DEFINE ManyReferenceDefinition FOR ManyReferenceCondition»
	«IF !this.isCreate»
		// find new variable from many-reference: «this.source.variableName»:«this.source.typeName» -> «this.referenceName» -> «this.target.variableName»:«this.target.typeName»
		«LET (Rule)this.eContainer AS rule»
	    «this.target.typeName» «this.target.variableName» = «rule.name.toFirstLower()»_find«this.target.variableName.toFirstUpper()»(«source.variableName»);
	    «ENDLET»
	«ENDIF»
«ENDDEFINE»

«DEFINE VariableAssignmentDefinition FOR VariableAssignment»
    «variableName» = «value»;
«ENDDEFINE»

«DEFINE AttributeDefinition FOR AttributeCondition»
	«IF !this.isCreate»
		// assert condition: «instance.variableName».«attributeName» == «attributeValueLiteral»
		assertAttributeCondition("«instance.variableName».«attributeName» == «attributeValueLiteral»", «toPropertyGetters(instance.variableName + "." + attributeName)» == «attributeValueLiteral»);	
	«ENDIF»
«ENDDEFINE»

«DEFINE RemoveModificationDefinition FOR Modification»
	«IF this.instance != null»
	// remove instance: «this.action» «this.instance.variableName» «this.instance.typeName»
	«ENDIF»
    «IF this.reference != null»
    // remove reference: «this.action» «this.reference.source.variableName»:«this.reference.source.typeName» -> «this.reference.referenceName» -> «this.reference.target.variableName»:«this.reference.target.typeName»
    «IF this.reference.metaType == SingleReferenceCondition»
        «this.reference.source.variableName».«setter(this.reference.referenceName)»(null);
    «ELSE»
		«this.reference.source.variableName».«getter(this.reference.referenceName)»().remove(«this.reference.target.variableName»);
    «ENDIF»
    «ENDIF»
«ENDDEFINE»

«DEFINE CreateModificationDefinition FOR Modification»
	«IF this.instance != null»
	// create instance: «this.action» «this.instance.variableName» «this.instance.typeName»
	«ENDIF»
    «IF this.reference != null»
    // create reference: «this.action» «this.reference.source.variableName»:«this.reference.source.typeName» -> «this.reference.referenceName» -> «this.reference.target.variableName»:«this.reference.target.typeName»
    «IF this.reference.metaType == SingleReferenceCondition»
	    «this.reference.source.variableName».«setter(this.reference.referenceName)»(«this.reference.target.variableName»);
	«ELSE»
		«this.reference.source.variableName».«getter(this.reference.referenceName)»().add(«this.reference.target.variableName»);
    «ENDIF»
    «ENDIF»
«ENDDEFINE»

«DEFINE AttributeModificationDefinition FOR Modification»
	// set attribute: «this.attribute.instance.variableName».«this.attribute.attributeName» := «this.attribute.attributeValueLiteral»
	«this.attribute.instance.variableName».«this.attribute.attributeName.setter()»(«this.newAttributeValue»);
«ENDDEFINE»

«DEFINE FindObjectDefinition FOR ManyReferenceCondition»
	«LET (Rule)this.eContainer AS rule»
	
	private «this.target.typeName» «rule.name.toFirstLower()»_find«this.target.variableName.toFirstUpper()»(«source.getConcreteTypeName()» source) {
		«this.target.typeName» result = null;
		
		for («this.type.eType.name» «getVariableNameForFindReference()» : source.«getter(this.referenceName)»()) {
		    «IF isPolymorphic()»
		      if (!(«getVariableNameForFindReference()» instanceof «this.target.typeName»)) {
		        continue;
		      }
		      «this.target.typeName» «this.target.variableName» = («this.target.typeName»)«getVariableNameForFindReference()»;
		    «ENDIF»
			«EXPAND AttributeConditionsForFindObjectDefinition FOREACH rule.attributeConditions.select(e|!e.isCreate && e.instance == this.target)»
			«EXPAND ReferenceConditionsForFindObjectDefinition FOREACH rule.referenceConditions.typeSelect(SingleReferenceCondition).select(e|!e.isCreate && e.source == this.target)»
			
			result = «this.target.variableName»;
			break;
        }
		assertObjectFound("«this.referenceName»", "«this.target.typeName»", result);
		return result;
    }
    
    «ENDLET»
«ENDDEFINE»

«DEFINE AttributeConditionsForFindObjectDefinition FOR AttributeCondition»
	// attribute check: «instance.variableName»: «this.attributeName»
	if («toPropertyGetters(instance.variableName + "." + this.attributeName)» != «attributeValueLiteral») {
		continue;
	}
«ENDDEFINE»

«DEFINE ReferenceConditionsForFindObjectDefinition FOR SingleReferenceCondition»
	// reference check: «source.variableName»: «this.referenceName»
    «IF this.isForbid»
    if («source.variableName».«getter(this.referenceName)»() != null) {	 	   
	«ELSE»
    «target.typeName» «target.variableName» = «source.variableName».«getter(this.referenceName)»();
	if («target.variableName» == null) {
    «ENDIF»
    	continue;
    }
    
	«LET (Rule)this.eContainer AS rule»
	«EXPAND AttributeConditionsForFindObjectDefinition FOREACH rule.attributeConditions.select(e|!e.isCreate && e.instance == this.target)»
	«EXPAND ReferenceConditionsForFindObjectDefinition FOREACH rule.referenceConditions.typeSelect(SingleReferenceCondition).select(e|!e.isCreate && e.source == this.target)»
	«ENDLET»
«ENDDEFINE»

«DEFINE Preconditions FOR Unit»
	«LET (Transformation)this.eContainer AS transformation-»
	«FOREACH getPreconditionsForCommand(transformation) AS p-»
	if ((«EXPAND template::operations::QueriesTemplate::PreconditionExpressionDefinition FOR p.expressions.get(0)-») == false) {
	    throw new RuntimeException("precondition violation");
	}
	«ENDFOREACH-»
	«ENDLET-»
«ENDDEFINE»
