«IMPORT commandBehavior»
«IMPORT queryBehavior»

«EXTENSION template::GeneratorExtensions»

«DEFINE main FOR Transformation»
    «FILE this.getCommandJavaPackagePath() + "/" + name.toFirstUpper() + "Command.java"»package «this.getCommandJavaPackageName()»;
    	
    	import de.unistuttgart.hamster.framework.*;
        import static de.unistuttgart.hamster.framework.FrameworkAssert.*;
    	«EXPAND template::types::ImportUsedTypesTemplate::CommandEntityImportDefinition FOR targetClass»
    	import «getModulePackage()».mpw.*;
    	import «getModulePackage()».command.*;
    	import de.unistuttgart.hamster.command.impl.*;
    	import static «getModulePackage()».mpw.Direction.*;
    	import java.util.stream.Collectors;
    	
    	«REM»TODO JML«constraints.toJml()»«ENDREM-»
    	«documentation.toJavaDoc()»
		public class «name.toFirstUpper()»Command extends CompositeCommandBase {
			private final «targetClass.getConcreteName()» thisInstance;
			«IF mainUnit != null»
			«FOREACH mainUnit.parameters AS p»
			private final «p.type.toJavaType()» «p.name»;
			«ENDFOREACH»
			«ENDIF»
		
			public «name.toFirstUpper()»Command(«name.toFirstUpper()»CommandParameters parameters) {
				this.thisInstance = parameters.self;
				«FOREACH mainUnit.parameters AS p-»
                   this.«p.name» = parameters.«p.name»;
                «ENDFOREACH-»
			}
		
			«EXPAND UnitExpand FOR mainUnit»
            «EXPAND UnitExpand FOREACH units.excluding(mainUnit)»
        }
    «ENDFILE»
    «FILE this.getCommandJavaPackagePath() + "/" + name.toFirstUpper() + "CommandParameters.java"»package «this.getCommandJavaPackageName()»;
        
        «EXPAND template::types::ImportUsedTypesTemplate::CommandEntityImportDefinition FOR targetClass»
        import «getModulePackage()».mpw.*;
        import «getModulePackage()».command.*;
        import de.unistuttgart.hamster.command.impl.*;
        
        public class «name.toFirstUpper()»CommandParameters {
            public «targetClass.getConcreteName()» self;
            public CommandStack commandStack;
            «FOREACH mainUnit.parameters AS p»
            public «p.type.toJavaType()» «p.name»;
            «ENDFOREACH»
        }
    «ENDFILE»
«ENDDEFINE»

«DEFINE UnitExpand FOR Unit»
    «IF mainUnit»@Override«ENDIF-»
	«getVisibility()» void «name»(«IF !mainUnit»«FOREACH parameters AS p SEPARATOR ", "»«p.type.toJavaType()» «p.name»«ENDFOREACH»«ENDIF») {
    «IF mainUnit-»
        «EXPAND PreconditionsDefinition FOR this»
        «EXPAND OldValueVariablesDefinition FOR this»
    «ENDIF-»
	«EXPAND UnitExpandBody FOR this»
    «IF mainUnit-»
        «EXPAND PostconditionsDefinition FOR this»
    «ENDIF-»
	}
	«EXPAND PostUnitExpand FOR this»
«ENDDEFINE»

«DEFINE UnitExpandBody FOR Unit»«ENDDEFINE»

«DEFINE UnitExpandBody FOR ConditionalUnit»
    if«FOREACH conditions AS c SEPARATOR " else if "-»
    («c.condition.toPropertyGetters()») {
	«EXPAND UnitInvokeExpand FOR c.unit»
	}
    «ENDFOREACH»
«ENDDEFINE»

«DEFINE UnitExpandBody FOR SequentialUnit»
	«EXPAND UnitInvokeExpand FOR this»
«ENDDEFINE»

«DEFINE UnitExpandBody FOR IteratedUnit»
	«EXPAND UnitInvokeExpand FOR this»
«ENDDEFINE»

«DEFINE UnitInvokeExpand FOR Unit»«ENDDEFINE»

«DEFINE UnitInvokeExpand FOR SequentialUnit»
	«FOREACH targetInvocations AS i»
	«i.targetMethodName»(«FOREACH i.mappedParameters AS p SEPARATOR ", "»«p.name»«ENDFOREACH»);
	«ENDFOREACH»
«ENDDEFINE»

«DEFINE UnitInvokeExpand FOR IteratedUnit»
	for (int i = 0; i < («repeat»); i++) {
		«targetInvocation.targetMethodName»(«FOREACH targetInvocation.mappedParameters AS p SEPARATOR ", "»«p.name»«ENDFOREACH»);
	}
«ENDDEFINE»

«DEFINE UnitInvokeExpand FOR Rule»
    «name»();
«ENDDEFINE»

«DEFINE UnitExpandBody FOR Rule»
    «EXPAND VariableDefinition FOREACH variables»
    «EXPAND InstanceDefinition FOREACH instanceConditions»
    «EXPAND ReferenceDefinition FOREACH referenceConditions»
    «EXPAND VariableAssignmentDefinition FOREACH variableAssignments»
    «EXPAND AttributeDefinition FOREACH attributeConditions»
    «EXPAND RemoveModificationDefinition FOREACH modifications.select(m|m.action == Action::DELETE)»
    «EXPAND ClearModificationDefinition FOREACH modifications.select(m|m.action == Action::CLEAR)»
    «EXPAND CreateModificationDefinition FOREACH modifications.select(m|m.action == Action::CREATE)»
    «EXPAND AttributeModificationDefinition FOREACH modifications.select(m|m.action == Action::MODIFY)»
«ENDDEFINE»

«DEFINE PostUnitExpand FOR Unit»«ENDDEFINE»

«DEFINE PostUnitExpand FOR Rule»
    «EXPAND FindObjectDefinition FOREACH referenceConditions.typeSelect(ManyReferenceCondition).select(r|!r.isCreate)»
«ENDDEFINE»

«DEFINE ThisInstanceDefinition FOR InstanceCondition»
    // this: «this.variableName»:«this.typeName»
«ENDDEFINE»

«DEFINE InstanceDefinition FOR InstanceCondition»
	«IF isCreate»
		// new instance: «this.variableName»:«this.typeName»
    	«this.typeName» «this.variableName» = new «this.typeName»();
	«ENDIF»
«ENDDEFINE»

«DEFINE VariableDefinition FOR VariableDeclaration»
    // new variable «this.name»: «this.type»
    «this.type.toJavaType()» «this.name»;
«ENDDEFINE»

«DEFINE ReferenceDefinition FOR ReferenceCondition»
	«IF this.metaType == SingleReferenceCondition»
      «EXPAND SingleReferenceDefinition FOR (SingleReferenceCondition)this»
    «ELSEIF this.metaType == ManyReferenceCondition»
      «EXPAND ManyReferenceDefinition FOR (ManyReferenceCondition)this»
	«ENDIF»
«ENDDEFINE»

«DEFINE SingleReferenceDefinition FOR SingleReferenceCondition»
	«IF !this.isCreate && !this.isForbid»
		// new variable from reference: «this.source.variableName»:«this.source.typeName» -> «this.referenceName» -> «this.target.variableName»:«this.target.typeName»
		«this.target.typeName» «this.target.variableName» = «this.source.variableName».«getter(this.referenceName)»();
		assertInstanceNotNull("«this.source.variableName».«this.referenceName»", «this.target.variableName»);
	«ENDIF»
«ENDDEFINE»

«DEFINE ManyReferenceDefinition FOR ManyReferenceCondition»
	«IF !this.isCreate»
		// find new variable from many-reference: «this.source.variableName»:«this.source.typeName» -> «this.referenceName» -> «this.target.variableName»:«this.target.typeName»
		«LET (Rule)this.eContainer AS rule»
	    «this.target.typeName» «this.target.variableName» = «rule.name.toFirstLower()»_find«this.target.variableName.toFirstUpper()»(«source.variableName»);
	    «ENDLET»
	«ENDIF»
«ENDDEFINE»

«DEFINE VariableAssignmentDefinition FOR VariableAssignment»
    «variableName» = «value.toPropertyGetters()»;
«ENDDEFINE»

«DEFINE AttributeDefinition FOR AttributeCondition»
	«IF this.isCreate»
	    «IF instance.typeName.isValueType()-»
    	    // set attribute condition «instance.variableName».«attributeName» := «attributeValueLiteral»
	        «instance.variableName».«attributeName.setter()»(«attributeValueLiteral.toPropertyGetters()»);
	    «ELSE»
	        // set value type field «instance.variableName».«attributeName» := «attributeValueLiteral»
	        «commandSetter()»(«instance.variableName», "«attributeName»", «instance.variableName».«attributeName.getter()»(), «attributeValueLiteral.toPropertyGetters()»);
	    «ENDIF-»
	«ELSE»	
		// assert condition: «instance.variableName».«attributeName» == «attributeValueLiteral»
		assertAttributeCondition("«instance.variableName».«attributeName» == «attributeValueLiteral.toPropertyGetters()»", «toPropertyGetters(instance.variableName + "." + attributeName)» == «attributeValueLiteral.toPropertyGetters()»);
	«ENDIF»
«ENDDEFINE»

«DEFINE RemoveModificationDefinition FOR Modification»
	«IF this.instance != null»
	// remove instance: «this.action» «this.instance.variableName» «this.instance.typeName»
	«ENDIF»
    «IF this.reference != null»
    // remove reference: «this.action» «this.reference.source.variableName»:«this.reference.source.typeName» -> «this.reference.referenceName» -> «this.reference.target.variableName»:«this.reference.target.typeName»
    «IF this.reference.metaType == SingleReferenceCondition»
        «commandSetter()»(«this.reference.source.variableName», "«this.reference.referenceName»", «this.reference.source.variableName».«this.reference.referenceName.getter()»(), null);
    «ELSE»
        «commandRemover()»(«this.reference.source.variableName», "«this.reference.referenceName»", «this.reference.target.variableName»);
    «ENDIF»
    «ENDIF»
«ENDDEFINE»

«DEFINE ClearModificationDefinition FOR Modification»
    «IF this.reference.metaType == ClearReferenceCondition»
        // clear references: «this.reference.source.variableName»:«this.reference.source.typeName» -> «this.reference.referenceName» -> «this.reference.target.variableName»:«this.reference.target.typeName»
        while («this.reference.source.variableName».«this.reference.referenceName.getter()»().size() > 0) {
            «commandRemover()»(«this.reference.source.variableName», "«this.reference.referenceName»", «this.reference.source.variableName».«this.reference.referenceName.getter()»().get(0));
        }
    «ENDIF»
«ENDDEFINE»

«DEFINE CreateModificationDefinition FOR Modification»
	«IF this.instance != null»
	// create instance: «this.action» «this.instance.variableName» «this.instance.typeName»
	«ENDIF»
    «IF this.reference != null»
    // create reference: «this.action» «this.reference.source.variableName»:«this.reference.source.typeName» -> «this.reference.referenceName» -> «this.reference.target.variableName»:«this.reference.target.typeName»
    «IF this.reference.metaType == SingleReferenceCondition»
        «commandSetter()»(«this.reference.source.variableName», "«this.reference.referenceName»", «this.reference.source.variableName».«this.reference.referenceName.getter()»(), «this.reference.target.variableName»);
	«ELSE»
	    «commandAdder()»(«this.reference.source.variableName», "«this.reference.referenceName»", «this.reference.target.variableName»);
    «ENDIF»
    «ENDIF»
«ENDDEFINE»

«DEFINE AttributeModificationDefinition FOR Modification»
	// set attribute: «this.attribute.instance.variableName».«this.attribute.attributeName» := «this.newAttributeValue»
	«commandSetter()»(«this.attribute.instance.variableName», "«this.attribute.attributeName»", «this.attribute.instance.variableName».«this.attribute.attributeName.getter()»(), «this.newAttributeValue»);
«ENDDEFINE»

«DEFINE FindObjectDefinition FOR ManyReferenceCondition»
	«LET (Rule)this.eContainer AS rule»
	
	private «this.target.typeName» «rule.name.toFirstLower()»_find«this.target.variableName.toFirstUpper()»(«source.getConcreteTypeName()» source) {
		«this.target.typeName» result = null;
		
		for («this.type.eType.name» «getVariableNameForFindReference()» : source.«getter(this.referenceName)»()) {
		    «IF isPolymorphic()»
		      if (!(«getVariableNameForFindReference()» instanceof «this.target.typeName»)) {
		        continue;
		      }
		      «this.target.typeName» «this.target.variableName» = («this.target.typeName»)«getVariableNameForFindReference()»;
		    «ENDIF»
			«EXPAND AttributeConditionsForFindObjectDefinition FOREACH rule.attributeConditions.select(e|!e.isCreate && e.instance == this.target)»
			«EXPAND ReferenceConditionsForFindObjectDefinition FOREACH rule.referenceConditions.typeSelect(SingleReferenceCondition).select(e|!e.isCreate && e.source == this.target)»
			
			result = «this.target.variableName»;
			break;
        }
		assertObjectFound("«this.referenceName»", "«this.target.typeName»", result);
		return result;
    }
    
    «ENDLET»
«ENDDEFINE»

«DEFINE AttributeConditionsForFindObjectDefinition FOR AttributeCondition»
	// attribute check: «instance.variableName»: «this.attributeName»
	if («toPropertyGetters(instance.variableName + "." + this.attributeName)» != «attributeValueLiteral.toPropertyGetters()») {
		continue;
	}
«ENDDEFINE»

«DEFINE ReferenceConditionsForFindObjectDefinition FOR SingleReferenceCondition»
	// reference check: «source.variableName»: «this.referenceName»
    «IF this.isForbid»
    if («source.variableName».«getter(this.referenceName)»() != null) {	 	   
	«ELSE»
    «target.typeName» «target.variableName» = «source.variableName».«getter(this.referenceName)»();
	if («target.variableName» == null) {
    «ENDIF»
    	continue;
    }
    
	«LET (Rule)this.eContainer AS rule»
	«EXPAND AttributeConditionsForFindObjectDefinition FOREACH rule.attributeConditions.select(e|!e.isCreate && e.instance == this.target)»
	«EXPAND ReferenceConditionsForFindObjectDefinition FOREACH rule.referenceConditions.typeSelect(SingleReferenceCondition).select(e|!e.isCreate && e.source == this.target)»
	«ENDLET»
«ENDDEFINE»

«DEFINE PreconditionsDefinition FOR Unit»
	«LET (Transformation)this.eContainer AS transformation-»
	«EXPAND ConstraintDefinition FOREACH transformation.constraints.typeSelect(Precondition)-»
	«IF !transformation.isInit-»
        «EXPAND ConstraintDefinition FOREACH transformation.constraints.typeSelect(ClassInvariant)-»
	«ENDIF-»
	«ENDLET-»
«ENDDEFINE»

«DEFINE OldValueVariablesDefinition FOR Unit»
	«LET (Transformation)this.eContainer AS transformation-»
	«EXPAND template::QueriesTemplate::ExpressionDefinition FOREACH transformation.constraints.typeSelect(Postcondition).collect(c|c.oldValueVariableExpressions).flatten()-»
	«ENDLET-»
«ENDDEFINE»

«DEFINE PostconditionsDefinition FOR Unit»
	«LET (Transformation)this.eContainer AS transformation-»
	«EXPAND ConstraintDefinition FOREACH transformation.constraints.typeSelect(Postcondition)-»
	«EXPAND ConstraintDefinition FOREACH transformation.constraints.typeSelect(ClassInvariant)-»
	«ENDLET-»
«ENDDEFINE»

«DEFINE ConstraintDefinition FOR Constraint»
    «documentation.toComment()»
	if ((«EXPAND template::QueriesTemplate::ExpressionDefinition FOR this.mainExpression-») == false) {
	    throw new CommandConstraintException("«constraintToViolationString()»");
	}
«ENDDEFINE»
