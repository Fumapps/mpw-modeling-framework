import commandBehavior;
import queryBehavior;
import ecore;

extension template::types::EmfGeneratorExtensions;
extension template::util::GlobalsGeneratorExtensions;

getCommandJavaPackagePath(Transformation this) :
  this.getCommandJavaPackageName().replaceAll("\\.", "/");

getCommandJavaPackageName(Transformation this) :
  getModulePackage() + ".commands";

Transformation getCommandForOperation(EOperation operation) : 
    operation.eAnnotations.selectFirst(a|a.source == "command").contents.first();

getConcreteName(EClass this) : "Concrete" + name;

getConcreteTypeName(InstanceCondition this) :
  let transformation = (Transformation)eRootContainer : 
  if (transformation.targetClass.name == this.typeName) then "Concrete" + this.typeName
  else this.typeName;

getVisibility(Unit this) : 
  if (name == "execute") then "public" else "private";
  
getVariableNameForFindReference(ManyReferenceCondition this) :
  if (isPolymorphic()) then target.variableName + this.type.eType.name
  else target.variableName;
  
isPolymorphic(ManyReferenceCondition this) :
  this.type.eType.name != this.target.typeName;
  
getParentTransformation(Unit this):
    (Transformation)eContainer;
  
toLogMessage(Transformation this):
    name.toFirstUpper().replaceAll("([a-z])([A-Z])", "$1 $2");
  
isActorCommand(Transformation this):
    targetClass.eAllSuperTypes.exists(t|t.name == "Actor");
    
commandSetter() : "executeSetProperty";
    
commandAdder() : "executeAddReference";
    
commandRemover() : "executeRemoveReference";

toJml(List[Constraint] this) : 
    if (size > 0) then 
    "/*@\n" +
    collect(c|"@ " + c.toJmlKeyword() + " " + c.name + "\n").toString("") +
    "@*/"
    else "";
    
private toJmlKeyword(Constraint this) :
    if (Precondition.isInstance(this)) then "requires"
    else if (Postcondition.isInstance(this)) then "ensures"
    else "invariant";
