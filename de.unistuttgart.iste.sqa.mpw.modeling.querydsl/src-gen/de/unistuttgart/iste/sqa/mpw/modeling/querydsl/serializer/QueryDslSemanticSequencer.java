/*
 * generated by Xtext 2.23.0
 */
package de.unistuttgart.iste.sqa.mpw.modeling.querydsl.serializer;

import com.google.inject.Inject;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.AndExpression;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.BoolConstant;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.ClassContext;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.CommandContext;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.ComparisonExpression;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.DivisionExpression;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.EqualityExpression;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.ImpliesExpression;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.IntConstant;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.Invariant;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.MethodCall;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.MinusExpression;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.MultiplicationExpression;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.NotExpression;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.NullConstant;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.OldValueExpression;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.OrExpression;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.ParameterList;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.ParametrizedCollectionMethod;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.PlusExpression;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.Postcondition;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.Precondition;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.Query;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.QuerydslPackage;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.SimpleCollectionMethod;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.Statement;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.StatementsExpression;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.StringConstant;
import de.unistuttgart.iste.sqa.mpw.modeling.querydsl.services.QueryDslGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class QueryDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private QueryDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == QuerydslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case QuerydslPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case QuerydslPackage.BOOL_CONSTANT:
				sequence_ConstantExpression(context, (BoolConstant) semanticObject); 
				return; 
			case QuerydslPackage.CLASS_CONTEXT:
				sequence_ClassContext(context, (ClassContext) semanticObject); 
				return; 
			case QuerydslPackage.COMMAND_CONTEXT:
				sequence_CommandContext(context, (CommandContext) semanticObject); 
				return; 
			case QuerydslPackage.COMPARISON_EXPRESSION:
				sequence_ComparisonExpression(context, (ComparisonExpression) semanticObject); 
				return; 
			case QuerydslPackage.DIVISION_EXPRESSION:
				sequence_MultiplicationOrDivisionExpression(context, (DivisionExpression) semanticObject); 
				return; 
			case QuerydslPackage.EQUALITY_EXPRESSION:
				sequence_EqualityExpression(context, (EqualityExpression) semanticObject); 
				return; 
			case QuerydslPackage.IMPLIES_EXPRESSION:
				sequence_ImpliesExpression(context, (ImpliesExpression) semanticObject); 
				return; 
			case QuerydslPackage.INT_CONSTANT:
				sequence_ConstantExpression(context, (IntConstant) semanticObject); 
				return; 
			case QuerydslPackage.INVARIANT:
				sequence_Invariant(context, (Invariant) semanticObject); 
				return; 
			case QuerydslPackage.METHOD_CALL:
				sequence_MethodCall(context, (MethodCall) semanticObject); 
				return; 
			case QuerydslPackage.MINUS_EXPRESSION:
				sequence_PlusOrMinusExpression(context, (MinusExpression) semanticObject); 
				return; 
			case QuerydslPackage.MULTIPLICATION_EXPRESSION:
				sequence_MultiplicationOrDivisionExpression(context, (MultiplicationExpression) semanticObject); 
				return; 
			case QuerydslPackage.NOT_EXPRESSION:
				sequence_PrimaryExpression(context, (NotExpression) semanticObject); 
				return; 
			case QuerydslPackage.NULL_CONSTANT:
				sequence_ConstantExpression(context, (NullConstant) semanticObject); 
				return; 
			case QuerydslPackage.OLD_VALUE_EXPRESSION:
				sequence_OldValueExpression(context, (OldValueExpression) semanticObject); 
				return; 
			case QuerydslPackage.OR_EXPRESSION:
				sequence_OrExpression(context, (OrExpression) semanticObject); 
				return; 
			case QuerydslPackage.PARAMETER:
				sequence_Parameter(context, (de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.Parameter) semanticObject); 
				return; 
			case QuerydslPackage.PARAMETER_LIST:
				sequence_ParameterList(context, (ParameterList) semanticObject); 
				return; 
			case QuerydslPackage.PARAMETRIZED_COLLECTION_METHOD:
				sequence_ParametrizedCollectionMethod(context, (ParametrizedCollectionMethod) semanticObject); 
				return; 
			case QuerydslPackage.PLUS_EXPRESSION:
				sequence_PlusOrMinusExpression(context, (PlusExpression) semanticObject); 
				return; 
			case QuerydslPackage.POSTCONDITION:
				sequence_Postcondition(context, (Postcondition) semanticObject); 
				return; 
			case QuerydslPackage.PRECONDITION:
				sequence_Precondition(context, (Precondition) semanticObject); 
				return; 
			case QuerydslPackage.QUERY:
				sequence_Query(context, (Query) semanticObject); 
				return; 
			case QuerydslPackage.SIMPLE_COLLECTION_METHOD:
				sequence_SimpleCollectionMethod(context, (SimpleCollectionMethod) semanticObject); 
				return; 
			case QuerydslPackage.STATEMENT:
				if (rule == grammarAccess.getNavigatedStatementRule()) {
					sequence_NavigatedStatement(context, (Statement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_Statement(context, (Statement) semanticObject); 
					return; 
				}
				else break;
			case QuerydslPackage.STATEMENTS_EXPRESSION:
				sequence_PropertyPathExpression(context, (StatementsExpression) semanticObject); 
				return; 
			case QuerydslPackage.STRING_CONSTANT:
				sequence_ConstantExpression(context, (StringConstant) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns AndExpression
	 *     ImpliesExpression returns AndExpression
	 *     ImpliesExpression.ImpliesExpression_1_0 returns AndExpression
	 *     OrExpression returns AndExpression
	 *     OrExpression.OrExpression_1_0 returns AndExpression
	 *     AndExpression returns AndExpression
	 *     AndExpression.AndExpression_1_0 returns AndExpression
	 *     EqualityExpression returns AndExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns AndExpression
	 *     ComparisonExpression returns AndExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns AndExpression
	 *     PlusOrMinusExpression returns AndExpression
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns AndExpression
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns AndExpression
	 *     MultiplicationOrDivisionExpression returns AndExpression
	 *     MultiplicationOrDivisionExpression.MultiplicationExpression_1_0_0_0 returns AndExpression
	 *     MultiplicationOrDivisionExpression.DivisionExpression_1_0_1_0 returns AndExpression
	 *     PrimaryExpression returns AndExpression
	 *
	 * Constraint:
	 *     (left=AndExpression_AndExpression_1_0 right=EqualityExpression)
	 */
	protected void sequence_AndExpression(ISerializationContext context, AndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QuerydslPackage.Literals.AND_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QuerydslPackage.Literals.AND_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, QuerydslPackage.Literals.AND_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QuerydslPackage.Literals.AND_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndExpressionAccess().getRightEqualityExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns ClassContext
	 *     Context returns ClassContext
	 *     ClassContext returns ClassContext
	 *
	 * Constraint:
	 *     (className=ID elements+=Element+)
	 */
	protected void sequence_ClassContext(ISerializationContext context, ClassContext semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns CommandContext
	 *     Context returns CommandContext
	 *     CommandContext returns CommandContext
	 *
	 * Constraint:
	 *     (className=ID commandName=ID parameterList=ParameterList? elements+=Element+)
	 */
	protected void sequence_CommandContext(ISerializationContext context, CommandContext semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ComparisonExpression
	 *     ImpliesExpression returns ComparisonExpression
	 *     ImpliesExpression.ImpliesExpression_1_0 returns ComparisonExpression
	 *     OrExpression returns ComparisonExpression
	 *     OrExpression.OrExpression_1_0 returns ComparisonExpression
	 *     AndExpression returns ComparisonExpression
	 *     AndExpression.AndExpression_1_0 returns ComparisonExpression
	 *     EqualityExpression returns ComparisonExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns ComparisonExpression
	 *     ComparisonExpression returns ComparisonExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns ComparisonExpression
	 *     PlusOrMinusExpression returns ComparisonExpression
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns ComparisonExpression
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns ComparisonExpression
	 *     MultiplicationOrDivisionExpression returns ComparisonExpression
	 *     MultiplicationOrDivisionExpression.MultiplicationExpression_1_0_0_0 returns ComparisonExpression
	 *     MultiplicationOrDivisionExpression.DivisionExpression_1_0_1_0 returns ComparisonExpression
	 *     PrimaryExpression returns ComparisonExpression
	 *
	 * Constraint:
	 *     (left=ComparisonExpression_ComparisonExpression_1_0 (op='>=' | op='<=' | op='>' | op='<') right=PlusOrMinusExpression)
	 */
	protected void sequence_ComparisonExpression(ISerializationContext context, ComparisonExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BoolConstant
	 *     ImpliesExpression returns BoolConstant
	 *     ImpliesExpression.ImpliesExpression_1_0 returns BoolConstant
	 *     OrExpression returns BoolConstant
	 *     OrExpression.OrExpression_1_0 returns BoolConstant
	 *     AndExpression returns BoolConstant
	 *     AndExpression.AndExpression_1_0 returns BoolConstant
	 *     EqualityExpression returns BoolConstant
	 *     EqualityExpression.EqualityExpression_1_0 returns BoolConstant
	 *     ComparisonExpression returns BoolConstant
	 *     ComparisonExpression.ComparisonExpression_1_0 returns BoolConstant
	 *     PlusOrMinusExpression returns BoolConstant
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns BoolConstant
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns BoolConstant
	 *     MultiplicationOrDivisionExpression returns BoolConstant
	 *     MultiplicationOrDivisionExpression.MultiplicationExpression_1_0_0_0 returns BoolConstant
	 *     MultiplicationOrDivisionExpression.DivisionExpression_1_0_1_0 returns BoolConstant
	 *     PrimaryExpression returns BoolConstant
	 *     ConstantExpression returns BoolConstant
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_ConstantExpression(ISerializationContext context, BoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IntConstant
	 *     ImpliesExpression returns IntConstant
	 *     ImpliesExpression.ImpliesExpression_1_0 returns IntConstant
	 *     OrExpression returns IntConstant
	 *     OrExpression.OrExpression_1_0 returns IntConstant
	 *     AndExpression returns IntConstant
	 *     AndExpression.AndExpression_1_0 returns IntConstant
	 *     EqualityExpression returns IntConstant
	 *     EqualityExpression.EqualityExpression_1_0 returns IntConstant
	 *     ComparisonExpression returns IntConstant
	 *     ComparisonExpression.ComparisonExpression_1_0 returns IntConstant
	 *     PlusOrMinusExpression returns IntConstant
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns IntConstant
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns IntConstant
	 *     MultiplicationOrDivisionExpression returns IntConstant
	 *     MultiplicationOrDivisionExpression.MultiplicationExpression_1_0_0_0 returns IntConstant
	 *     MultiplicationOrDivisionExpression.DivisionExpression_1_0_1_0 returns IntConstant
	 *     PrimaryExpression returns IntConstant
	 *     ConstantExpression returns IntConstant
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_ConstantExpression(ISerializationContext context, IntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QuerydslPackage.Literals.INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QuerydslPackage.Literals.INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantExpressionAccess().getValueINTTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NullConstant
	 *     ImpliesExpression returns NullConstant
	 *     ImpliesExpression.ImpliesExpression_1_0 returns NullConstant
	 *     OrExpression returns NullConstant
	 *     OrExpression.OrExpression_1_0 returns NullConstant
	 *     AndExpression returns NullConstant
	 *     AndExpression.AndExpression_1_0 returns NullConstant
	 *     EqualityExpression returns NullConstant
	 *     EqualityExpression.EqualityExpression_1_0 returns NullConstant
	 *     ComparisonExpression returns NullConstant
	 *     ComparisonExpression.ComparisonExpression_1_0 returns NullConstant
	 *     PlusOrMinusExpression returns NullConstant
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns NullConstant
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns NullConstant
	 *     MultiplicationOrDivisionExpression returns NullConstant
	 *     MultiplicationOrDivisionExpression.MultiplicationExpression_1_0_0_0 returns NullConstant
	 *     MultiplicationOrDivisionExpression.DivisionExpression_1_0_1_0 returns NullConstant
	 *     PrimaryExpression returns NullConstant
	 *     ConstantExpression returns NullConstant
	 *
	 * Constraint:
	 *     value='null'
	 */
	protected void sequence_ConstantExpression(ISerializationContext context, NullConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QuerydslPackage.Literals.NULL_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QuerydslPackage.Literals.NULL_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantExpressionAccess().getValueNullKeyword_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringConstant
	 *     ImpliesExpression returns StringConstant
	 *     ImpliesExpression.ImpliesExpression_1_0 returns StringConstant
	 *     OrExpression returns StringConstant
	 *     OrExpression.OrExpression_1_0 returns StringConstant
	 *     AndExpression returns StringConstant
	 *     AndExpression.AndExpression_1_0 returns StringConstant
	 *     EqualityExpression returns StringConstant
	 *     EqualityExpression.EqualityExpression_1_0 returns StringConstant
	 *     ComparisonExpression returns StringConstant
	 *     ComparisonExpression.ComparisonExpression_1_0 returns StringConstant
	 *     PlusOrMinusExpression returns StringConstant
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns StringConstant
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns StringConstant
	 *     MultiplicationOrDivisionExpression returns StringConstant
	 *     MultiplicationOrDivisionExpression.MultiplicationExpression_1_0_0_0 returns StringConstant
	 *     MultiplicationOrDivisionExpression.DivisionExpression_1_0_1_0 returns StringConstant
	 *     PrimaryExpression returns StringConstant
	 *     ConstantExpression returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_ConstantExpression(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QuerydslPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QuerydslPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantExpressionAccess().getValueSTRINGTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns EqualityExpression
	 *     ImpliesExpression returns EqualityExpression
	 *     ImpliesExpression.ImpliesExpression_1_0 returns EqualityExpression
	 *     OrExpression returns EqualityExpression
	 *     OrExpression.OrExpression_1_0 returns EqualityExpression
	 *     AndExpression returns EqualityExpression
	 *     AndExpression.AndExpression_1_0 returns EqualityExpression
	 *     EqualityExpression returns EqualityExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns EqualityExpression
	 *     ComparisonExpression returns EqualityExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns EqualityExpression
	 *     PlusOrMinusExpression returns EqualityExpression
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns EqualityExpression
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns EqualityExpression
	 *     MultiplicationOrDivisionExpression returns EqualityExpression
	 *     MultiplicationOrDivisionExpression.MultiplicationExpression_1_0_0_0 returns EqualityExpression
	 *     MultiplicationOrDivisionExpression.DivisionExpression_1_0_1_0 returns EqualityExpression
	 *     PrimaryExpression returns EqualityExpression
	 *
	 * Constraint:
	 *     (left=EqualityExpression_EqualityExpression_1_0 (operation='=' | operation='<>') right=ComparisonExpression)
	 */
	protected void sequence_EqualityExpression(ISerializationContext context, EqualityExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ImpliesExpression
	 *     ImpliesExpression returns ImpliesExpression
	 *     ImpliesExpression.ImpliesExpression_1_0 returns ImpliesExpression
	 *     OrExpression returns ImpliesExpression
	 *     OrExpression.OrExpression_1_0 returns ImpliesExpression
	 *     AndExpression returns ImpliesExpression
	 *     AndExpression.AndExpression_1_0 returns ImpliesExpression
	 *     EqualityExpression returns ImpliesExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns ImpliesExpression
	 *     ComparisonExpression returns ImpliesExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns ImpliesExpression
	 *     PlusOrMinusExpression returns ImpliesExpression
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns ImpliesExpression
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns ImpliesExpression
	 *     MultiplicationOrDivisionExpression returns ImpliesExpression
	 *     MultiplicationOrDivisionExpression.MultiplicationExpression_1_0_0_0 returns ImpliesExpression
	 *     MultiplicationOrDivisionExpression.DivisionExpression_1_0_1_0 returns ImpliesExpression
	 *     PrimaryExpression returns ImpliesExpression
	 *
	 * Constraint:
	 *     (left=ImpliesExpression_ImpliesExpression_1_0 right=OrExpression)
	 */
	protected void sequence_ImpliesExpression(ISerializationContext context, ImpliesExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QuerydslPackage.Literals.IMPLIES_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QuerydslPackage.Literals.IMPLIES_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, QuerydslPackage.Literals.IMPLIES_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QuerydslPackage.Literals.IMPLIES_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImpliesExpressionAccess().getImpliesExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getImpliesExpressionAccess().getRightOrExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Invariant
	 *     Invariant returns Invariant
	 *
	 * Constraint:
	 *     (documentation=DOCUMENTATION? name=ID? expressions+=Expression)
	 */
	protected void sequence_Invariant(ISerializationContext context, Invariant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MethodCall returns MethodCall
	 *
	 * Constraint:
	 *     (targetMethod=ID parameters+=ID*)
	 */
	protected void sequence_MethodCall(ISerializationContext context, MethodCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns DivisionExpression
	 *     ImpliesExpression returns DivisionExpression
	 *     ImpliesExpression.ImpliesExpression_1_0 returns DivisionExpression
	 *     OrExpression returns DivisionExpression
	 *     OrExpression.OrExpression_1_0 returns DivisionExpression
	 *     AndExpression returns DivisionExpression
	 *     AndExpression.AndExpression_1_0 returns DivisionExpression
	 *     EqualityExpression returns DivisionExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns DivisionExpression
	 *     ComparisonExpression returns DivisionExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns DivisionExpression
	 *     PlusOrMinusExpression returns DivisionExpression
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns DivisionExpression
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns DivisionExpression
	 *     MultiplicationOrDivisionExpression returns DivisionExpression
	 *     MultiplicationOrDivisionExpression.MultiplicationExpression_1_0_0_0 returns DivisionExpression
	 *     MultiplicationOrDivisionExpression.DivisionExpression_1_0_1_0 returns DivisionExpression
	 *     PrimaryExpression returns DivisionExpression
	 *
	 * Constraint:
	 *     (left=MultiplicationOrDivisionExpression_DivisionExpression_1_0_1_0 right=PrimaryExpression)
	 */
	protected void sequence_MultiplicationOrDivisionExpression(ISerializationContext context, DivisionExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QuerydslPackage.Literals.DIVISION_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QuerydslPackage.Literals.DIVISION_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, QuerydslPackage.Literals.DIVISION_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QuerydslPackage.Literals.DIVISION_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationOrDivisionExpressionAccess().getDivisionExpressionLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationOrDivisionExpressionAccess().getRightPrimaryExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MultiplicationExpression
	 *     ImpliesExpression returns MultiplicationExpression
	 *     ImpliesExpression.ImpliesExpression_1_0 returns MultiplicationExpression
	 *     OrExpression returns MultiplicationExpression
	 *     OrExpression.OrExpression_1_0 returns MultiplicationExpression
	 *     AndExpression returns MultiplicationExpression
	 *     AndExpression.AndExpression_1_0 returns MultiplicationExpression
	 *     EqualityExpression returns MultiplicationExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns MultiplicationExpression
	 *     ComparisonExpression returns MultiplicationExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns MultiplicationExpression
	 *     PlusOrMinusExpression returns MultiplicationExpression
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns MultiplicationExpression
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns MultiplicationExpression
	 *     MultiplicationOrDivisionExpression returns MultiplicationExpression
	 *     MultiplicationOrDivisionExpression.MultiplicationExpression_1_0_0_0 returns MultiplicationExpression
	 *     MultiplicationOrDivisionExpression.DivisionExpression_1_0_1_0 returns MultiplicationExpression
	 *     PrimaryExpression returns MultiplicationExpression
	 *
	 * Constraint:
	 *     (left=MultiplicationOrDivisionExpression_MultiplicationExpression_1_0_0_0 right=PrimaryExpression)
	 */
	protected void sequence_MultiplicationOrDivisionExpression(ISerializationContext context, MultiplicationExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QuerydslPackage.Literals.MULTIPLICATION_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QuerydslPackage.Literals.MULTIPLICATION_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, QuerydslPackage.Literals.MULTIPLICATION_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QuerydslPackage.Literals.MULTIPLICATION_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationOrDivisionExpressionAccess().getMultiplicationExpressionLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationOrDivisionExpressionAccess().getRightPrimaryExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NavigatedStatement returns Statement
	 *
	 * Constraint:
	 *     (methodCall=MethodCall | target=ID | collectionTarget=CollectionMethod)
	 */
	protected void sequence_NavigatedStatement(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns OldValueExpression
	 *     ImpliesExpression returns OldValueExpression
	 *     ImpliesExpression.ImpliesExpression_1_0 returns OldValueExpression
	 *     OrExpression returns OldValueExpression
	 *     OrExpression.OrExpression_1_0 returns OldValueExpression
	 *     AndExpression returns OldValueExpression
	 *     AndExpression.AndExpression_1_0 returns OldValueExpression
	 *     EqualityExpression returns OldValueExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns OldValueExpression
	 *     ComparisonExpression returns OldValueExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns OldValueExpression
	 *     PlusOrMinusExpression returns OldValueExpression
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns OldValueExpression
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns OldValueExpression
	 *     MultiplicationOrDivisionExpression returns OldValueExpression
	 *     MultiplicationOrDivisionExpression.MultiplicationExpression_1_0_0_0 returns OldValueExpression
	 *     MultiplicationOrDivisionExpression.DivisionExpression_1_0_1_0 returns OldValueExpression
	 *     PrimaryExpression returns OldValueExpression
	 *     OldValueExpression returns OldValueExpression
	 *
	 * Constraint:
	 *     expression=PropertyPathExpression
	 */
	protected void sequence_OldValueExpression(ISerializationContext context, OldValueExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QuerydslPackage.Literals.OLD_VALUE_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QuerydslPackage.Literals.OLD_VALUE_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOldValueExpressionAccess().getExpressionPropertyPathExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns OrExpression
	 *     ImpliesExpression returns OrExpression
	 *     ImpliesExpression.ImpliesExpression_1_0 returns OrExpression
	 *     OrExpression returns OrExpression
	 *     OrExpression.OrExpression_1_0 returns OrExpression
	 *     AndExpression returns OrExpression
	 *     AndExpression.AndExpression_1_0 returns OrExpression
	 *     EqualityExpression returns OrExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns OrExpression
	 *     ComparisonExpression returns OrExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns OrExpression
	 *     PlusOrMinusExpression returns OrExpression
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns OrExpression
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns OrExpression
	 *     MultiplicationOrDivisionExpression returns OrExpression
	 *     MultiplicationOrDivisionExpression.MultiplicationExpression_1_0_0_0 returns OrExpression
	 *     MultiplicationOrDivisionExpression.DivisionExpression_1_0_1_0 returns OrExpression
	 *     PrimaryExpression returns OrExpression
	 *
	 * Constraint:
	 *     (left=OrExpression_OrExpression_1_0 right=AndExpression)
	 */
	protected void sequence_OrExpression(ISerializationContext context, OrExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QuerydslPackage.Literals.OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QuerydslPackage.Literals.OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, QuerydslPackage.Literals.OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QuerydslPackage.Literals.OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrExpressionAccess().getRightAndExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ParameterList returns ParameterList
	 *
	 * Constraint:
	 *     (parameters+=Parameter parameters+=Parameter*)
	 */
	protected void sequence_ParameterList(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (variableName=ID typeName=ID)
	 */
	protected void sequence_Parameter(ISerializationContext context, de.unistuttgart.iste.sqa.mpw.modeling.querydsl.querydsl.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QuerydslPackage.Literals.PARAMETER__VARIABLE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QuerydslPackage.Literals.PARAMETER__VARIABLE_NAME));
			if (transientValues.isValueTransient(semanticObject, QuerydslPackage.Literals.PARAMETER__TYPE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QuerydslPackage.Literals.PARAMETER__TYPE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getVariableNameIDTerminalRuleCall_0_0(), semanticObject.getVariableName());
		feeder.accept(grammarAccess.getParameterAccess().getTypeNameIDTerminalRuleCall_2_0(), semanticObject.getTypeName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CollectionMethod returns ParametrizedCollectionMethod
	 *     ParametrizedCollectionMethod returns ParametrizedCollectionMethod
	 *
	 * Constraint:
	 *     (typeSelect=ID | indexExpression=Expression)
	 */
	protected void sequence_ParametrizedCollectionMethod(ISerializationContext context, ParametrizedCollectionMethod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MinusExpression
	 *     ImpliesExpression returns MinusExpression
	 *     ImpliesExpression.ImpliesExpression_1_0 returns MinusExpression
	 *     OrExpression returns MinusExpression
	 *     OrExpression.OrExpression_1_0 returns MinusExpression
	 *     AndExpression returns MinusExpression
	 *     AndExpression.AndExpression_1_0 returns MinusExpression
	 *     EqualityExpression returns MinusExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns MinusExpression
	 *     ComparisonExpression returns MinusExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns MinusExpression
	 *     PlusOrMinusExpression returns MinusExpression
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns MinusExpression
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns MinusExpression
	 *     MultiplicationOrDivisionExpression returns MinusExpression
	 *     MultiplicationOrDivisionExpression.MultiplicationExpression_1_0_0_0 returns MinusExpression
	 *     MultiplicationOrDivisionExpression.DivisionExpression_1_0_1_0 returns MinusExpression
	 *     PrimaryExpression returns MinusExpression
	 *
	 * Constraint:
	 *     (left=PlusOrMinusExpression_MinusExpression_1_0_1_0 right=MultiplicationOrDivisionExpression)
	 */
	protected void sequence_PlusOrMinusExpression(ISerializationContext context, MinusExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QuerydslPackage.Literals.MINUS_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QuerydslPackage.Literals.MINUS_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, QuerydslPackage.Literals.MINUS_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QuerydslPackage.Literals.MINUS_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusExpressionAccess().getMinusExpressionLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusExpressionAccess().getRightMultiplicationOrDivisionExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PlusExpression
	 *     ImpliesExpression returns PlusExpression
	 *     ImpliesExpression.ImpliesExpression_1_0 returns PlusExpression
	 *     OrExpression returns PlusExpression
	 *     OrExpression.OrExpression_1_0 returns PlusExpression
	 *     AndExpression returns PlusExpression
	 *     AndExpression.AndExpression_1_0 returns PlusExpression
	 *     EqualityExpression returns PlusExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns PlusExpression
	 *     ComparisonExpression returns PlusExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns PlusExpression
	 *     PlusOrMinusExpression returns PlusExpression
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns PlusExpression
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns PlusExpression
	 *     MultiplicationOrDivisionExpression returns PlusExpression
	 *     MultiplicationOrDivisionExpression.MultiplicationExpression_1_0_0_0 returns PlusExpression
	 *     MultiplicationOrDivisionExpression.DivisionExpression_1_0_1_0 returns PlusExpression
	 *     PrimaryExpression returns PlusExpression
	 *
	 * Constraint:
	 *     (left=PlusOrMinusExpression_PlusExpression_1_0_0_0 right=MultiplicationOrDivisionExpression)
	 */
	protected void sequence_PlusOrMinusExpression(ISerializationContext context, PlusExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QuerydslPackage.Literals.PLUS_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QuerydslPackage.Literals.PLUS_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, QuerydslPackage.Literals.PLUS_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QuerydslPackage.Literals.PLUS_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusExpressionAccess().getPlusExpressionLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusExpressionAccess().getRightMultiplicationOrDivisionExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Postcondition
	 *     CommandConstraint returns Postcondition
	 *     Postcondition returns Postcondition
	 *
	 * Constraint:
	 *     (documentation=DOCUMENTATION? name=ID? expressions+=Expression)
	 */
	protected void sequence_Postcondition(ISerializationContext context, Postcondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Precondition
	 *     CommandConstraint returns Precondition
	 *     Precondition returns Precondition
	 *
	 * Constraint:
	 *     (documentation=DOCUMENTATION? name=ID? expressions+=Expression)
	 */
	protected void sequence_Precondition(ISerializationContext context, Precondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NotExpression
	 *     ImpliesExpression returns NotExpression
	 *     ImpliesExpression.ImpliesExpression_1_0 returns NotExpression
	 *     OrExpression returns NotExpression
	 *     OrExpression.OrExpression_1_0 returns NotExpression
	 *     AndExpression returns NotExpression
	 *     AndExpression.AndExpression_1_0 returns NotExpression
	 *     EqualityExpression returns NotExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns NotExpression
	 *     ComparisonExpression returns NotExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns NotExpression
	 *     PlusOrMinusExpression returns NotExpression
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns NotExpression
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns NotExpression
	 *     MultiplicationOrDivisionExpression returns NotExpression
	 *     MultiplicationOrDivisionExpression.MultiplicationExpression_1_0_0_0 returns NotExpression
	 *     MultiplicationOrDivisionExpression.DivisionExpression_1_0_1_0 returns NotExpression
	 *     PrimaryExpression returns NotExpression
	 *
	 * Constraint:
	 *     expression=PrimaryExpression
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, NotExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QuerydslPackage.Literals.NOT_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QuerydslPackage.Literals.NOT_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExpressionAccess().getExpressionPrimaryExpressionParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StatementsExpression
	 *     ImpliesExpression returns StatementsExpression
	 *     ImpliesExpression.ImpliesExpression_1_0 returns StatementsExpression
	 *     OrExpression returns StatementsExpression
	 *     OrExpression.OrExpression_1_0 returns StatementsExpression
	 *     AndExpression returns StatementsExpression
	 *     AndExpression.AndExpression_1_0 returns StatementsExpression
	 *     EqualityExpression returns StatementsExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns StatementsExpression
	 *     ComparisonExpression returns StatementsExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns StatementsExpression
	 *     PlusOrMinusExpression returns StatementsExpression
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns StatementsExpression
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns StatementsExpression
	 *     MultiplicationOrDivisionExpression returns StatementsExpression
	 *     MultiplicationOrDivisionExpression.MultiplicationExpression_1_0_0_0 returns StatementsExpression
	 *     MultiplicationOrDivisionExpression.DivisionExpression_1_0_1_0 returns StatementsExpression
	 *     PrimaryExpression returns StatementsExpression
	 *     PropertyPathExpression returns StatementsExpression
	 *
	 * Constraint:
	 *     (statements+=Statement statements+=NavigatedStatement*)
	 */
	protected void sequence_PropertyPathExpression(ISerializationContext context, StatementsExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Query
	 *     Query returns Query
	 *
	 * Constraint:
	 *     (documentation=DOCUMENTATION? internal?='internal'? name=ID parameterList=ParameterList? expressions+=Expression)
	 */
	protected void sequence_Query(ISerializationContext context, Query semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CollectionMethod returns SimpleCollectionMethod
	 *     SimpleCollectionMethod returns SimpleCollectionMethod
	 *
	 * Constraint:
	 *     (method='notEmpty' | method='isEmpty' | method='size')
	 */
	protected void sequence_SimpleCollectionMethod(ISerializationContext context, SimpleCollectionMethod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Statement
	 *
	 * Constraint:
	 *     (target='self' | target=Direction | target=ID)
	 */
	protected void sequence_Statement(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
