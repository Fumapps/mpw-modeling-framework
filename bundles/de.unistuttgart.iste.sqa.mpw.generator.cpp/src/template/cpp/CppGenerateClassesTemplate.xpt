«IMPORT ecore»
«IMPORT commandBehavior»
«IMPORT queryBehavior»
«IMPORT generationAnnotations»

«EXTENSION template::cpp::CppGeneratorExtensions»

«REM»
  Generates classes based on GenerationAnnotationDefinition(EClass class)s.
  Note: currently only facade classes are generated by this approach. Later it is planned to generate also the 
        other entity classes by the usage of GenerationAnnotationDefinition(EClass class)s to move logic to the transformation step.
«ENDREM»
«DEFINE main FOR EPackage»
    «EXPAND CppClass FOREACH this.eClassifiers.typeSelect(EClass)
                                               .select(c|c.isFacade())
                                               .reject(c|c.interface)»
«ENDDEFINE»

«DEFINE CppClass FOR EClass»
    «EXPAND CppClassHeader FOR this»
    «EXPAND CppClassSource FOR this»
«ENDDEFINE»

«DEFINE CppClassHeader FOR EClass-»
    «FILE "generated/" + name + ".h"»«toCppHeaderGeneratedComment()»
    
    #ifndef «this.toCppIncludeGuard()»
    #define «this.toCppIncludeGuard()»
    
    «EXPAND template::cpp::types::CppImportUsedTypesTemplate::HeaderImportDefinitions FOR this»
    
    «EXPAND template::cpp::types::CppImportUsedTypesTemplate::ForwardDeclarations FOR this»
    
    namespace «this.ePackage.name» {
    
    «documentationToCppDoc()-»
    class «name» «toInheritance()» {
        private:

        «FOREACH eStructuralFeatures AS f-»
            «f.documentationToCppDoc()-»
            «f.featureToSimpleFieldType()» «f.name»;
        «ENDFOREACH-»
        
        public:

        «FOREACH eOperations AS o-»
		    «o.documentationToCppDoc()-»
            «o.operationToCppType()» «o.name» («FOREACH o.eParameters AS p SEPARATOR ", "»«p.eType.toCppType()» «p.name»«ENDFOREACH»);
        «ENDFOREACH»
        «EXPAND GenerationAnnotationDeclaration FOREACH eAnnotations»
    };
    
    }
    
    #endif //«this.toCppIncludeGuard()»
    «ENDFILE»
«ENDDEFINE»

«DEFINE CppClassSource FOR EClass-»
    «FILE "generated/" + name + ".cpp"»«toCppHeaderGeneratedComment()»

    #include "«name».h"
    
    «EXPAND template::cpp::types::CppImportUsedTypesTemplate::SourceImportDefinitions FOR this»
    
    namespace «this.ePackage.name» {
    
        «FOREACH eOperations AS o-»
            «o.operationToCppType()» «name»::«o.name»(«FOREACH o.eParameters AS p SEPARATOR ", "»«p.eType.toCppType()» «p.name»«ENDFOREACH») {
            «EXPAND GenerationAnnotationOperationDefinition FOREACH o.eAnnotations-»
            }
            
        «ENDFOREACH»
        «EXPAND GenerationAnnotationDefinition(this) FOREACH eAnnotations»
    }
    
    «ENDFILE»
«ENDDEFINE»

«REM»
    Annotation Declarations
«ENDREM»
«DEFINE GenerationAnnotationDeclaration FOR EAnnotation»«ENDDEFINE-»

«DEFINE GenerationAnnotationDeclaration FOR GetPropertyAnnotation-»
    «documentationToCppDoc()-»
    «getterType.toCppType()» «getterOperationName»();
«ENDDEFINE»

«REM»
    Annotation Definitions
«ENDREM»
«DEFINE GenerationAnnotationDefinition(EClass class) FOR EAnnotation»«ENDDEFINE-»

«DEFINE GenerationAnnotationDefinition(EClass class) FOR GetPropertyAnnotation-»
    «getterType.toCppType()» «class.name»::«getterOperationName»() {
        return this->«field.resolveFieldValue()»;
    }
    
«ENDDEFINE»

«DEFINE GenerationAnnotationOperationDefinition FOR EAnnotation»«ENDDEFINE»

«DEFINE GenerationAnnotationOperationDefinition FOR CommandParameterCreationAnnotation-»
    commands::«command.name.toFirstUpper()»CommandParameters «parametersVariableName»(
    /*self*/ nullptr, *game.lock()->get«command.roleName.toFirstUpper()»CommandStack()
    «IF command.isActorCommand()-»
    , game.lock()->getGameLog()
    «ENDIF-»
    «FOREACH parameterMappings AS mapping-»
         , «mapping.value-»
    «ENDFOREACH-»
    );
«ENDDEFINE»

«DEFINE GenerationAnnotationOperationDefinition FOR CommandCallAnnotation-»
    «IF command.isActorCommand()-»
	    game.lock()->getPerformance()->preExecuteGameCommand();
	    try {
	        «targetRoleVariableName»->«command.name»(«parametersVariableName»);
	        game.lock()->getPerformance()->delayControlFlow();
	    } catch (std::exception& e) {
	        // Stop the game to prevent execution of further commands!
	        game.lock()->getPerformance()->setMode(mpw::Mode::STOPPED);
	        throw; // rethrow
	    }
    «ELSE-»
        game.lock()->getPerformance()->preExecuteEditorCommand();
        «targetRoleVariableName»->«command.name»(«parametersVariableName»);
    «ENDIF-»
«ENDDEFINE»

«DEFINE GenerationAnnotationOperationDefinition FOR QueryCallAnnotation-»
    return «internalRoleField.name»->«query.name»(«query.parameters.collect(p|p.name).toString(", ")»); 
«ENDDEFINE»

«DEFINE GenerationAnnotationOperationDefinition FOR ParameterToFieldAssignmentAnnotation-»
    this->«field.name» = «parameter.name»;
«ENDDEFINE»

«DEFINE GenerationAnnotationOperationDefinition FOR ConstructorSimpleFieldInitializationAnnotation-»
    this->«field.name» = std::make_shared<«constructorTypeName»>(«EXPAND template::cpp::CppQueriesTemplate::ExpressionDefinition FOREACH parameterInputVariableExpressions SEPARATOR ", "»);
«ENDDEFINE»

«DEFINE GenerationAnnotationOperationDefinition FOR ExpressionFieldAssignmentAnnotation-»
    this->«field.name» = «EXPAND template::cpp::CppQueriesTemplate::ExpressionDefinition FOR expression»;
«ENDDEFINE»

«DEFINE GenerationAnnotationOperationDefinition FOR AddVariableToCollectionAnnotation-»
    «EXPAND template::cpp::CppQueriesTemplate::ExpressionDefinition FOR collectionExpression».push_back(«EXPAND template::cpp::CppQueriesTemplate::ExpressionDefinition FOR parameterExpression»);
«ENDDEFINE»

«DEFINE GenerationAnnotationOperationDefinition FOR MethodCallAnnotation-»
    «variableName»->«methodName»(«EXPAND template::cpp::CppQueriesTemplate::ExpressionDefinition FOREACH parameterInputVariableExpressions SEPARATOR ", "»)«IF closingStatement»;«ENDIF-»
«ENDDEFINE»

«DEFINE GenerationAnnotationOperationDefinition FOR ReturnAnnotation-»
    return «toOptionalDereferencingStar()»«EXPAND template::cpp::CppQueriesTemplate::ExpressionDefinition FOR expression»;
«ENDDEFINE»

«DEFINE GenerationAnnotationOperationDefinition FOR ExpressionAnnotation-»
    «EXPAND template::cpp::CppQueriesTemplate::ExpressionDefinition FOR expression-»
«ENDDEFINE»

«DEFINE GenerationAnnotationOperationDefinition FOR VariableObjectConstructionAnnotation-»
    «constructorType.toCppType()» «variableName»«IF !constructorType.isValueType()» = std::make_shared<«constructorType.toQualifiedTypeName()»>«ENDIF»(«EXPAND template::cpp::CppQueriesTemplate::ExpressionDefinition FOREACH parameterInputVariableExpressions SEPARATOR ", "»);
«ENDDEFINE»

«DEFINE GenerationAnnotationOperationDefinition FOR VariableDefinitionAnnotation-»
    auto «variableName» = «EXPAND GenerationAnnotationOperationDefinition FOR rhs»;
«ENDDEFINE»

«REM»NOT USED for C++«ENDREM»
«DEFINE ImportTypeGenerationAnnotationDefinition(EClass class) FOR ImportTypeAnnotation-»
«ENDDEFINE»
