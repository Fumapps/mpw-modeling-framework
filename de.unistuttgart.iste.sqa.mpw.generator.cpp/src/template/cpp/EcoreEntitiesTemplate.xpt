«IMPORT ecore»
«IMPORT generationAnnotations»

«EXTENSION template::cpp::GeneratorExtensions»

«REM»
  Generate entity ecore files.
«ENDREM»
«DEFINE main FOR List[EPackage]»
    «EXPAND EcoreFile FOREACH this»
«ENDDEFINE»

«DEFINE EcoreFile FOR EPackage»
    «EXPAND CppClass FOREACH this.eClassifiers.typeSelect(EClass)
                                 .reject(c|c.interface)
                                 .reject(c|c.isValueType())
                                 .reject(c|c.isFacade())»
    «EXPAND CppStubClass FOREACH this.eClassifiers.typeSelect(EClass)
                                 .select(c|c.isFacade())»
    «EXPAND CppStubClass FOREACH this.eClassifiers.typeSelect(EClass)
                                 .select(c|c.isValueType())»
    «EXPAND CppInterface FOREACH this.eClassifiers.typeSelect(EClass).select(c|c.interface)»
    «EXPAND CppEnum FOREACH this.eClassifiers.typeSelect(EEnum)»
«ENDDEFINE»

«DEFINE CppClass FOR EClass»
    «EXPAND CppClassHeader FOR this»
    «EXPAND CppClassSource FOR this»
«ENDDEFINE»

«DEFINE CppClassHeader FOR EClass»
    «FILE "generated/" + name + ".h"»
    
    #ifndef «this.toCppIncludeGuard()»
    #define «this.toCppIncludeGuard()»
    
    «EXPAND template::cpp::types::ImportUsedTypesTemplate::HeaderImportDefinitions FOR this»
    
    «EXPAND template::cpp::types::ImportUsedTypesTemplate::ForwardDeclarations FOR this»
    
    namespace «this.ePackage.name» {
    
    class «this.name» «this.toInheritance()» {
    
    private:
    
      «this.toInheritedAlias()-»
    
      «EXPAND template::cpp::properties::PropertyTemplate::PropertyDefinitions FOR this»
      
    public:
      «EXPAND template::cpp::properties::PropertyTemplate::ConstructorDeclaration FOR this»
      «REM»«EXPAND template::commands::CommandCallsTemplate::CommandDefinitions FOR this»«ENDREM»
      «EXPAND template::cpp::properties::PropertyTemplate::GetPropertyDeclarations FOR this»
      «EXPAND template::cpp::properties::PropertyTemplate::GetPropertyValueDeclarations FOR this»
      «EXPAND template::cpp::properties::PropertyTemplate::SetPropertyValueDeclarations FOR this»
      
    public:
    
      virtual ~«this.name»() = default;
        
      «FOREACH eOperations AS o-»
      «o.operationToSignature()» = 0;
      «ENDFOREACH-»
      
      «IF isInheritedEntity()-»
      void setProperty(const std::string& propertyName, Any value) override;
      void addToCollection(const std::string& propertyName, EntityReference reference) override;
      void removeFromCollection(const std::string& propertyName, EntityReference reference) override;
      «ENDIF-»
    };
    
    }
    
    #endif //«this.toCppIncludeGuard()»
    
    «ENDFILE»
«ENDDEFINE»

«DEFINE CppClassSource FOR EClass»
    «FILE "generated/" + name + ".cpp"»#include "«name».h"
    
    «EXPAND template::cpp::types::ImportUsedTypesTemplate::SourceImportDefinitions FOR this»
    
    namespace «this.ePackage.name» {
    
        «EXPAND template::cpp::properties::PropertyTemplate::ConstructorDefinition FOR this»
        «EXPAND template::cpp::properties::PropertyTemplate::GetPropertyDefinitions FOR this»
        «EXPAND template::cpp::properties::PropertyTemplate::GetPropertyValueDefinitions FOR this»
        «EXPAND template::cpp::properties::PropertyTemplate::SetPropertyValueDefinitions FOR this»
        «FOREACH eOperations AS o»
        // «o.operationToSignature()»;
        «ENDFOREACH»

        «IF isInheritedEntity()-»
        void «name»::setProperty(const std::string& propertyName, Any value) {
            «FOREACH eStructuralFeatures.select(f|f.changeable && f.upperBound == 1) AS f-»
            if (propertyName == "«f.name»") {
                «IF f.eType.isValueType()-»
                // TODO value type
                «ELSEIF EReference.isInstance(f)-»
                auto reference = std::get<EntityReference>(value);
                auto typedElement = reinterpret_cast<«f.eType.name»*>(reference);
                auto sharedPtr = std::static_pointer_cast<«f.eType.name»>(typedElement->shared_from_this());
                «f.name.setter()»(sharedPtr);
                «ELSEIF f.eType.isEnum()-»
                // TODO enum
                «ELSE-»
                auto typedValue = std::get<«f.toCppType()»>(value);
                «f.name.setter()»(typedValue);
                «ENDIF-»
                return;
            }
            «ENDFOREACH-»
            
            «IF getBaseClass() != null-»
            inherited::setProperty(propertyName, value);
            «ELSE-»
            throw std::runtime_error("property '" + propertyName + "' is not supported");
            «ENDIF-»
        }
        
        void «name»::addToCollection(const std::string& propertyName, EntityReference reference) {
            «FOREACH eStructuralFeatures.select(f|f.changeable && f.upperBound == -1) AS f-»
            if (propertyName == "«f.name»") {
                «IF EReference.isInstance(f)-»
                auto typedElement = reinterpret_cast<«f.eType.name»*>(reference);
                auto sharedPtr = std::static_pointer_cast<«f.eType.name»>(typedElement->shared_from_this());
                «f.name.adder()»(sharedPtr);
                «ELSE-»
                auto typedValue = std::get<«f.toCppType()»>(value);
                «f.name.adder()»(typedValue);
                «ENDIF-»
                return;
            }
            «ENDFOREACH-»
            
            «IF getBaseClass() != null-»
            inherited::addToCollection(propertyName, reference);
            «ELSE-»
            throw std::runtime_error("property '" + propertyName + "' is not supported");
            «ENDIF-»
        }
        
        void «name»::removeFromCollection(const std::string& propertyName, EntityReference reference) {
            «FOREACH eStructuralFeatures.select(f|f.changeable && f.upperBound == -1) AS f-»
            if (propertyName == "«f.name»") {
                «IF EReference.isInstance(f)-»
                auto typedElement = reinterpret_cast<«f.eType.name»*>(reference);
                auto sharedPtr = std::static_pointer_cast<«f.eType.name»>(typedElement->shared_from_this());
                «f.name.remover()»(sharedPtr);
                «ELSE-»
                auto typedValue = std::get<«f.toCppType()»>(value);
                «f.name.remover()»(typedValue);
                «ENDIF-»
                return;
            }
            «ENDFOREACH-»
            
            «IF getBaseClass() != null-»
            inherited::removeFromCollection(propertyName, reference);
            «ELSE-»
            throw std::runtime_error("property '" + propertyName + "' is not supported");
            «ENDIF-»
        }
        «ENDIF-»
    }
    «ENDFILE»
«ENDDEFINE»

«REM»DUMMY«ENDREM»
«DEFINE CppStubClass FOR EClass»
    «FILE "generated/" + name + ".h"»
    
    #ifndef «this.toCppIncludeGuard()»
    #define «this.toCppIncludeGuard()»
    
    namespace «this.ePackage.name» {
    
    class «this.name» {
    
    public:
    
      virtual ~«this.name»() = default;
    };
    
    }
    
    #endif //«this.toCppIncludeGuard()»
    
    «ENDFILE»
«ENDDEFINE»

«DEFINE CppInterface FOR EClass»
    «FILE "generated/" + name + ".h"»
    
    #ifndef «this.toCppIncludeGuard()»
    #define «this.toCppIncludeGuard()»
    
    «EXPAND template::cpp::types::ImportUsedTypesTemplate::HeaderImportDefinitions FOR this»
    
    «EXPAND template::cpp::types::ImportUsedTypesTemplate::ForwardDeclarations FOR this»
    
    namespace «this.ePackage.name» {
    
    class «this.name» «this.toInheritance()» «IF name == "Entity"»: public std::enable_shared_from_this<Entity>, public ReflectivePropertyObject«ENDIF» {
    
    public:
    
      virtual ~«this.name»() = default;
        
      «FOREACH eOperations AS o»
      «o.operationToSignature()» = 0;
      «IF o.isPropertyGetter()-»
      «o.operationToObservableGetterSignature()» = 0;
      «ENDIF-»
      «ENDFOREACH»
      «EXPAND GenerationAnnotation FOREACH eAnnotations»
    };
    
    }
    
    #endif //«this.toCppIncludeGuard()»
    
    «ENDFILE»
«ENDDEFINE»

«DEFINE CppEnum FOR EEnum»
    «FILE "generated/" + name + ".h"»
    
    #ifndef «this.toCppIncludeGuard()»
    #define «this.toCppIncludeGuard()»
    
    namespace «this.ePackage.name» {
    
    enum class «this.name» {
      «FOREACH eLiterals AS l SEPARATOR ", "»
      «l»
	  «ENDFOREACH»
    };
    
    }
    
    #endif //«this.toCppIncludeGuard()»
    
    «ENDFILE»
«ENDDEFINE»

«DEFINE CMakeLists FOR List[EPackage]»
    «FILE "generated/CMakeLists.txt"-»
    
set(GEN_SRCS ${GEN_SRCS}
    «FOREACH this.eClassifiers.typeSelect(EClass)
                              .reject(c|c.isDataType())
                              .reject(c|c.interface)
                              .reject(c|c.isFacade())
                              .reject(c|c.isValueType()) AS c-»
    "core/src/generated/«c.name».cpp"
    «ENDFOREACH-»
    «FOREACH this.eClassifiers.typeSelect(EClass)
                              .reject(c|c.isDataType()) AS c-»
    "core/src/generated/«c.name».h"
    «ENDFOREACH-»
    «FOREACH this.eClassifiers.typeSelect(EEnum) AS c-»
    "core/src/generated/«c.name».h"
    «ENDFOREACH-»
    PARENT_SCOPE)
    «ENDFILE»
«ENDDEFINE»


«DEFINE GenerationAnnotation FOR EAnnotation»«ENDDEFINE»

«DEFINE GenerationAnnotation FOR GetPropertyDeclarationAnnotation»
    // «fieldTypeName» «getterName»();
«ENDDEFINE»
