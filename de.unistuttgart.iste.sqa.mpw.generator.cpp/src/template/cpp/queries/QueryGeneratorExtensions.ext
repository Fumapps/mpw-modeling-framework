import ecore;
import queryBehavior;
import commandBehavior;
import behaviorsbase;

extension template::cpp::types::EmfGeneratorExtensions;
extension template::cpp::types::MetaModelGeneratorExtensions;

/*
 * Extensions related to the generation of queries.
 */

toOperatorCode(CompareOperator this) :
    switch (this) {
       case CompareOperator::EQUAL: "=="
       case CompareOperator::NOT_EQUAL: "!="
       case CompareOperator::GREATER: ">"
       case CompareOperator::SMALLER: "<"
       case CompareOperator::GREATER_EQUAL: ">="
       case CompareOperator::SMALLER_EQUAL: "<="
       default: ""
    };

toOperatorCode(CalculationOperator this) :
    switch (this) {
       case CalculationOperator::PLUS: "+"
       case CalculationOperator::MINUS: "-"
       case CalculationOperator::MULTIPLY: "*"
       case CalculationOperator::DIVIDE: "/"
       default: ""
    };

Query getQueryForOperation(EOperation operation) : 
    operation.eAnnotations.selectFirst(a|a.source == "query").contents.first();
    
constraintToViolationString(queryBehavior::Constraint this) :
    let typeName = this.metaType.name.replaceAll("queryBehavior::", "") :
    "Violation of " + typeName + 
        (if (this.documentation != null) then ": " + documentation 
        else "");

toCppType(behaviorsbase::TypedElement element) :
    toCppType(element.type.name, element.type.metaType.name, element.type.ePackage);

getDefaultValueLiteralString(Query query) : toDefaultValueLiteralString(query, query.defaultValueLiteral);
    
private toDefaultValueLiteralString(TypedElement element, String originalLiteral) :
    if (element.isOptional) then "std::nullopt"
    else if (element.type.isValueType()) then "{}"
    else originalLiteral.toCppLiteral();
    
getDefaultValueLiteralString(IntermediaryResultStatement resultStatement) : 
    if (resultStatement.helperMethodResultType.isValueType()) then "{}"
    else resultStatement.helperMethodResultType.defaultValue.toString().toCppLiteral();

List[Parameter] findParameterList(Expression this) :
    eContainer.findParameterListOfEObject();

private List[Parameter] findParameterListOfEObject(emf::EObject object) :
    if (object == null) then null
    else if (Query.isInstance(object)) then ((Query)object).parameters
    else findParameterListOfEObject(object.eContainer);

EClassifier findContextClass(Expression this) :
    eContainer.findContextClassOfEObject();

private EClassifier findContextClassOfEObject(emf::EObject object) :
    if (object == null) then null
    else if (ExpressionalElement.isInstance(object)) then ((ExpressionalElement)object).contextClass
    else findContextClassOfEObject(object.eContainer);

isObjectReferenceAccess(Statement statement) :
    if (statement.previous.isCollection) then false
    else if (statement.previous != null && statement.previous.type.isObjectReference()) then true
    else false;
    
isFunctionStatement(Statement this) :
    let collectionMethodStatement = (CollectionMethodStatement)this :
    CollectionMethodStatement.isInstance(this) && (
        collectionMethodStatement.methodType == CollectionMethodType::AT ||
        collectionMethodStatement.methodType == CollectionMethodType::TYPE_SELECT);
    
getFunctionStatementCall(Statement this) :
    let collectionMethodStatement = (CollectionMethodStatement)this :
    if (collectionMethodStatement.methodType == CollectionMethodType::AT) then "collectionhelpers::get_at("
    else if (collectionMethodStatement.methodType == CollectionMethodType::TYPE_SELECT) then (
        let selectedType = (EClassifier)collectionMethodStatement.parameters.get(0) :
        "collectionhelpers::type_select<" + selectedType.ePackage.name + "::" + selectedType.name + ">(" )
    else "";
    
toCppQueryReturnType(Query this) : 
    if (this.isOptional) then "std::optional<" + toCppType() + ">"
    else toCppType();

accessor(ReferenceCondition this) : accessor(this.source);
accessor(AttributeCondition this) : accessor(this.instance);

accessor(InstanceCondition this) :
    if (this.instanceType.isValueType()) then "."
    else "->";
    